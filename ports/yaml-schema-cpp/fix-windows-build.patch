diff --git a/include/yaml-schema-cpp/type_check.hpp b/include/yaml-schema-cpp/type_check.hpp
index a73df4c..3c50cfb 100644
--- a/include/yaml-schema-cpp/type_check.hpp
+++ b/include/yaml-schema-cpp/type_check.hpp
@@ -18,12 +18,12 @@ namespace yaml_schema_cpp
 #define CHECK_TYPE_CASE(TypeName) CHECK_STRING_TYPE_CASE(TypeName, TypeName);
 
 #define CHECK_TYPE_EIGEN_CASE(size)                                                                                   \
-    if (type == "Vector" #size "d" or type == "Eigen::Vector" #size "d")                                              \
+    if (type == "Vector" #size "d" || type == "Eigen::Vector" #size "d")                                              \
     {                                                                                                                 \
         node.as<Eigen::Matrix<double, size, 1> >();                                                                   \
         return true;                                                                                                  \
     }                                                                                                                 \
-    if (type == "Matrix" #size "d" or type == "Eigen::Matrix" #size "d")                                              \
+    if (type == "Matrix" #size "d" || type == "Eigen::Matrix" #size "d")                                              \
     {                                                                                                                 \
         node.as<Eigen::Matrix<double, size, size> >();                                                                \
         return true;                                                                                                  \
@@ -108,7 +108,7 @@ bool isNonTrivialType(const std::string& type, const std::vector<std::string>& f
 #define COMPARE_TYPE(TypeName) COMPARE_STRING_TYPE(TypeName, TypeName);
 
 #define COMPARE_EIGEN(size)                                                                                           \
-    if (type == "Vector" #size "d" or type == "Eigen::Vector" #size "d")                                              \
+    if (type == "Vector" #size "d" || type == "Eigen::Vector" #size "d")                                              \
     {                                                                                                                 \
         try                                                                                                           \
         {                                                                                                             \
@@ -121,7 +121,7 @@ bool isNonTrivialType(const std::string& type, const std::vector<std::string>& f
             return false;                                                                                             \
         }                                                                                                             \
     }                                                                                                                 \
-    if (type == "Matrix" #size "d" or type == "Eigen::Matrix" #size "d")                                              \
+    if (type == "Matrix" #size "d" || type == "Eigen::Matrix" #size "d")                                              \
     {                                                                                                                 \
         try                                                                                                           \
         {                                                                                                             \
@@ -138,10 +138,10 @@ bool isNonTrivialType(const std::string& type, const std::vector<std::string>& f
 static bool compare(const YAML::Node& node1, const YAML::Node& node2, const std::string& type)
 {
     // sequence
-    if (type.front() == '[' and type.back() == ']')
+    if (type.front() == '[' && type.back() == ']')
     {
         // both sequences
-        if (not node1.IsSequence() or not node2.IsSequence()) return false;
+        if (not node1.IsSequence() || not node2.IsSequence()) return false;
 
         // same size
         if (node1.size() != node2.size()) return false;
@@ -185,11 +185,11 @@ static bool compare(const YAML::Node& node1, const YAML::Node& node2, const std:
 }
 
 #define SETZERO_EIGEN(size)                                                                                           \
-    if (type == "Vector" #size "d" or type == "Eigen::Vector" #size "d")                                              \
+    if (type == "Vector" #size "d" || type == "Eigen::Vector" #size "d")                                              \
     {                                                                                                                 \
         node = Eigen::Matrix<double, size, 1>::Zero();                                                                \
     }                                                                                                                 \
-    if (type == "Matrix" #size "d" or type == "Eigen::Matrix" #size "d")                                              \
+    if (type == "Matrix" #size "d" || type == "Eigen::Matrix" #size "d")                                              \
     {                                                                                                                 \
         node = Eigen::Matrix<double, size, size>::Zero();                                                             \
     }
@@ -197,12 +197,12 @@ static bool compare(const YAML::Node& node1, const YAML::Node& node2, const std:
 static void setZero(YAML::Node& node, const std::string& type)
 {
     if (type == "bool") node = "false";
-    if (type == "int" or type == "unsigned int" or type == "long int" or type == "long unsigned int") node = "0";
-    if (type == "float" or type == "double") node = "0.0";
+    if (type == "int" || type == "unsigned int" || type == "long int" || type == "long unsigned int") node = "0";
+    if (type == "float" || type == "double") node = "0.0";
     if (type == "char") node = "A";
-    if (type == "string" or type == "std::string") node = "whatever";
-    if (type == "VectorXd" or type == "Eigen::VectorXd") node = Eigen::VectorXd::Zero(3);
-    if (type == "MatrixXd" or type == "Eigen::MatrixXd") node = Eigen::MatrixXd::Zero(3, 2);
+    if (type == "string" || type == "std::string") node = "whatever";
+    if (type == "VectorXd" || type == "Eigen::VectorXd") node = Eigen::VectorXd::Zero(3);
+    if (type == "MatrixXd" || type == "Eigen::MatrixXd") node = Eigen::MatrixXd::Zero(3, 2);
 
     SETZERO_EIGEN(1)
     SETZERO_EIGEN(2)
@@ -219,16 +219,15 @@ static void setZero(YAML::Node& node, const std::string& type)
 static std::string getZeroString(const std::string& type)
 {
     if (type == "bool") return "false";
-    if (type == "int" or type == "unsigned int" or type == "long int" or type == "long unsigned int") return "0";
-    if (type == "float" or type == "double") return "0.0";
+    if (type == "int" || type == "unsigned int" || type == "long int" || type == "long unsigned int") return "0";
+    if (type == "float" || type == "double") return "0.0";
     if (type == "char") return "A";
-    if (type == "string" or type == "std::string") return "whatever";
-    if (type == "VectorXd" or type == "Eigen::VectorXd") return "[0.0, 0.0, 0.0]";
-    if (type == "MatrixXd" or type == "Eigen::MatrixXd") return "[[3, 2], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]";
-
+    if (type == "string" || type == "std::string") return "whatever";
+    if (type == "VectorXd" || type == "Eigen::VectorXd") return "[0.0, 0.0, 0.0]";
+    if (type == "MatrixXd" || type == "Eigen::MatrixXd") return "[[3, 2], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]";
     for (auto i = 1; i <= 10; i++)
     {
-        if (type == "Vector" + std::to_string(i) + "d" or type == "Eigen::Vector" + std::to_string(i) + "d")
+        if (type == "Vector" + std::to_string(i) + "d" || type == "Eigen::Vector" + std::to_string(i) + "d")
         {
             std::string string_ret = "[0.0";
             for (auto j = 2; j <= i; j++) string_ret += ", 0.0";
@@ -237,7 +236,7 @@ static std::string getZeroString(const std::string& type)
             return string_ret;
         }
 
-        if (type == "Matrix" + std::to_string(i) + "d" or type == "Eigen::Matrix" + std::to_string(i) + "d")
+        if (type == "Matrix" + std::to_string(i) + "d" || type == "Eigen::Matrix" + std::to_string(i) + "d")
         {
             std::string string_ret = "[0.0";
             for (auto j = 2; j <= i * i; j++) string_ret += ", 0.0";
diff --git a/include/yaml-schema-cpp/yaml_conversion.hpp b/include/yaml-schema-cpp/yaml_conversion.hpp
index 81114e8..d660f8a 100644
--- a/include/yaml-schema-cpp/yaml_conversion.hpp
+++ b/include/yaml-schema-cpp/yaml_conversion.hpp
@@ -55,9 +55,9 @@ struct convert<Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols
 
         // ==========================================================================================
         // Special case empty vector/matrix
-        if (node.IsSequence() and node.size() == 0)
+        if (node.IsSequence() && node.size() == 0)
         {
-            if (_Rows != Eigen::Dynamic and _Cols != Eigen::Dynamic)
+            if (_Rows != Eigen::Dynamic && _Cols != Eigen::Dynamic)
             {
                 std::cout << "Empty input sequence with not dynamic matrix" << std::endl;
                 return false;
diff --git a/src/expression.cpp b/src/expression.cpp
index 1117b65..849d0bd 100644
--- a/src/expression.cpp
+++ b/src/expression.cpp
@@ -93,8 +93,8 @@ struct schema_USR : public parser_t::unknown_symbol_resolver
             error_message = "checkExpression: The parameter '" + unknown_symbol + "' is not a basic type";
         }
         // mandatory (bool and true or with default
-        else if (not(tryNodeAs(schema_[unknown_symbol][MANDATORY], "bool") and
-                     (schema_[unknown_symbol][MANDATORY].as<bool>() or schema_[unknown_symbol][DEFAULT])))
+        else if (not(tryNodeAs(schema_[unknown_symbol][MANDATORY], "bool") &&
+                     (schema_[unknown_symbol][MANDATORY].as<bool>() || schema_[unknown_symbol][DEFAULT])))
         {
             error_message = "checkExpression: The parameter '" + unknown_symbol +
                             "' is not mandatory (expressions with optional parameters not implemented yet)";
diff --git a/src/yaml_schema.cpp b/src/yaml_schema.cpp
index 0089c43..1e0d454 100644
--- a/src/yaml_schema.cpp
+++ b/src/yaml_schema.cpp
@@ -70,7 +70,7 @@ void checkSchema(const YAML::Node&               node_schema,
                  const std::vector<std::string>& folders_schema)
 {
     // skip scalars and not defined (empty schemas)
-    if (node_schema.IsScalar() or node_schema.IsNull()) return;
+    if (node_schema.IsScalar() || node_schema.IsNull()) return;
 
     // Check that node_schema is map
     if (not node_schema.IsMap())
@@ -209,7 +209,7 @@ void checkSchema(const YAML::Node&               node_schema,
 
             // if 'value', 'mandatory' should be false (no sense requiring user to define something already
             // defined)
-            if (isExpression(node_schema[MANDATORY]) or node_schema[MANDATORY].as<bool>())
+            if (isExpression(node_schema[MANDATORY]) || node_schema[MANDATORY].as<bool>())
             {
                 throw std::runtime_error("YAML schema: " + node_field + ", if " + VALUE + " defined, " + MANDATORY +
                                          " should be false");
@@ -624,7 +624,7 @@ bool applySchemaRecursive(YAML::Node&                     node_input,
             // Check if it is mandatory
             else
             {
-                assert(tryNodeAs(node_schema[MANDATORY], "bool") or isExpression(node_schema[MANDATORY]));
+                assert(tryNodeAs(node_schema[MANDATORY], "bool") || isExpression(node_schema[MANDATORY]));
                 bool mandatory;
                 if (isExpression(node_schema[MANDATORY]))
                 {
diff --git a/src/yaml_template_generator.cpp b/src/yaml_template_generator.cpp
index 71182a3..c524f0d 100644
--- a/src/yaml_template_generator.cpp
+++ b/src/yaml_template_generator.cpp
@@ -27,7 +27,7 @@ int main(int argc, char* argv[])
      */
 
     // HELP
-    if (argc == 2 and (std::string(argv[1]) == "-h" or std::string(argv[1]) == "--help"))
+    if (argc == 2 && (std::string(argv[1]) == "-h" || std::string(argv[1]) == "--help"))
     {
         cout << "--------- yaml_template_generator HELP ---------- \nCall it with:" << endl;
         cout << "yaml_template_generator schema_name schema_folders output_file" << endl << endl;
@@ -44,7 +44,7 @@ int main(int argc, char* argv[])
         return 0;
     }
     // Call
-    if (argc == 3 or argc == 4)
+    if (argc == 3 || argc == 4)
     {
         filesystem::path current_path(filesystem::current_path());
 
@@ -54,7 +54,7 @@ int main(int argc, char* argv[])
         // schema folders
         std::string              schema_folders_input(argv[2]);
         std::vector<std::string> schema_folders;
-        if (schema_folders_input.front() == '[' and schema_folders_input.back() == ']')
+        if (schema_folders_input.front() == '[' && schema_folders_input.back() == ']')
         {
             // remove '[' and ']'
             schema_folders_input.erase(0, 1);
diff --git a/src/yaml_utils.cpp b/src/yaml_utils.cpp
index ad14bd2..5047188 100644
--- a/src/yaml_utils.cpp
+++ b/src/yaml_utils.cpp
@@ -199,8 +199,8 @@ void addNodeYaml(YAML::Node&        node,
     if (node[key].Type() == YAML::NodeType::Scalar)
     {
         std::string value_str = node[key].as<std::string>();
-        if ((value_str.size() > 1 and value_str.substr(0, 2) == "./") or
-            (value_str.size() > 2 and value_str.substr(0, 3) == "../"))
+        if ((value_str.size() > 1 && value_str.substr(0, 2) == "./") ||
+            (value_str.size() > 2 && value_str.substr(0, 3) == "../"))
         {
             filesystem::path path_value = filesystem::path(parent_path) / filesystem::path(value.as<std::string>());
             node[key]                   = path_value.string();
@@ -212,11 +212,11 @@ std::string findFileRecursive(const std::string& name_with_extension, const std:
 {
     for (auto folder : folders)
     {
-        if (filesystem::exists(folder) and filesystem::is_directory(folder))
+        if (filesystem::exists(folder) && filesystem::is_directory(folder))
         {
             for (auto const& entry : filesystem::recursive_directory_iterator(folder))
             {
-                if (filesystem::is_regular_file(entry) and entry.path().filename().string() == name_with_extension)
+                if (filesystem::is_regular_file(entry) && entry.path().filename().string() == name_with_extension)
                 {
                     return entry.path().string();
                 }
@@ -263,7 +263,7 @@ std::vector<std::string> getAllSchemas(const std::vector<std::string>& root_fold
     std::vector<std::string> schemas_found;
     for (auto root_folder : root_folders)
         for (auto const& entry : filesystem::recursive_directory_iterator(root_folder))
-            if (filesystem::is_regular_file(entry) and entry.path().extension() == SCHEMA_EXTENSION)
+            if (filesystem::is_regular_file(entry) && entry.path().extension() == SCHEMA_EXTENSION)
                 schemas_found.push_back(entry.path().filename().string());
 
     return schemas_found;
