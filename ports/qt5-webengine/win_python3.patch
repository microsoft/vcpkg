diff --git a/src/3rdparty/chromium/build/toolchain/win/midl.py b/src/3rdparty/chromium/build/toolchain/win/midl.py
index ff4651b89..26f4bcba0 100644
--- a/src/3rdparty/chromium/build/toolchain/win/midl.py
+++ b/src/3rdparty/chromium/build/toolchain/win/midl.py
@@ -7,11 +7,11 @@ from __future__ import print_function
 
 import array
 import difflib
-import distutils.dir_util
 import filecmp
 import io
 import operator
 import os
+import posixpath
 import re
 import shutil
 import struct
@@ -173,25 +173,110 @@ def overwrite_cls_guid(h_file, iid_file, tlb_file, dynamic_guid):
   overwrite_cls_guid_tlb(tlb_file, dynamic_guid)
 
 
-def main(arch, gendir, outdir, dynamic_guid, tlb, h, dlldata, iid, proxy, clang,
-         idl, *flags):
+def main(arch, gendir, outdir, dynamic_guids, tlb, h, dlldata, iid, proxy,
+         clang, idl, *flags):
   # Copy checked-in outputs to final location.
   source = gendir
   if os.path.isdir(os.path.join(source, os.path.basename(idl))):
     source = os.path.join(source, os.path.basename(idl))
   source = os.path.join(source, arch.split('.')[1])  # Append 'x86' or 'x64'.
   source = os.path.normpath(source)
-  distutils.dir_util.copy_tree(source, outdir, preserve_times=False)
-  if dynamic_guid != 'none':
-    overwrite_cls_guid(os.path.join(outdir, h),
-                       os.path.join(outdir, iid),
-                       os.path.join(outdir, tlb),
-                       uuid.UUID(dynamic_guid))
+
+  source_exists = True
+  if not os.path.isdir(source):
+    source_exists = False
+    if sys.platform != 'win32':
+      print('Directory %s needs to be populated from Windows first' % source)
+      return 1
+
+    # This is a brand new IDL file that does not have outputs under
+    # third_party\win_build_output\midl. We create an empty directory for now.
+    os.makedirs(source)
+
+  common_files = [h, iid]
+  if tlb != 'none':
+    # Not all projects use tlb files.
+    common_files += [tlb]
+  else:
+    tlb = None
+
+  if dlldata != 'none':
+    # Not all projects use dlldta files.
+    common_files += [dlldata]
+  else:
+    dlldata = None
+
+  # Not all projects use proxy files
+  if proxy != 'none':
+    # Not all projects use proxy files.
+    common_files += [proxy]
+  else:
+    proxy = None
+
+  for source_file in common_files:
+    file_path = os.path.join(source, source_file)
+    if not os.path.isfile(file_path):
+      source_exists = False
+      if sys.platform != 'win32':
+        print('File %s needs to be generated from Windows first' % file_path)
+        return 1
+
+      # Either this is a brand new IDL file that does not have outputs under
+      # third_party\win_build_output\midl or the file is (unexpectedly) missing.
+      # We create an empty file for now. The rest of the machinery below will
+      # then generate the correctly populated file using the MIDL compiler and
+      # instruct the developer to copy that file under
+      # third_party\win_build_output\midl.
+      open(file_path, 'wb').close()
+    shutil.copy(file_path, outdir)
+
+  if dynamic_guids != 'none':
+    assert '=' in dynamic_guids
+    if dynamic_guids.startswith("ignore_proxy_stub,"):
+      # TODO(ganesh): The custom proxy/stub file ("_p.c") is not generated
+      # correctly for dynamic IIDs (but correctly if there are only dynamic
+      # CLSIDs). The proxy/stub lookup functions generated by MIDL.exe within
+      # "_p.c" rely on a sorted set of vtable lists, which we are not currently
+      # regenerating. At the moment, no project in Chromium that uses dynamic
+      # IIDs is relying on the custom proxy/stub file. So for now, if
+      # |dynamic_guids| is prefixed with "ignore_proxy_stub,", we exclude the
+      # custom proxy/stub file from the directory comparisons.
+      common_files.remove(proxy)
+      dynamic_guids = dynamic_guids.split("ignore_proxy_stub,", 1)[1]
+    dynamic_guids = re.sub('PLACEHOLDER-GUID-', '', dynamic_guids, flags=re.I)
+    dynamic_guids = dynamic_guids.split(',')
+    dynamic_guids = dict(s.split('=') for s in dynamic_guids)
+    uuid5_substitutions(dynamic_guids)
+    dynamic_guids_bytes = {
+        k.encode('utf-8'): v.encode('utf-8')
+        for k, v in dynamic_guids.items()
+    }
+    if source_exists:
+      overwrite_guids(*(os.path.join(outdir, file) if file else None
+                        for file in [h, iid, proxy, tlb]),
+                      dynamic_guids=dynamic_guids_bytes)
+  else:
+    dynamic_guids = None
 
   # On non-Windows, that's all we can do.
   if sys.platform != 'win32':
     return 0
 
+  idl_template = None
+  if dynamic_guids:
+    idl_template = idl
+
+    # posixpath is used here to keep the MIDL-generated files with a uniform
+    # separator of '/' instead of mixed '/' and '\\'.
+    idl = posixpath.join(
+        outdir,
+        os.path.splitext(os.path.basename(idl_template))[0] + '.idl')
+
+    # |idl_template| can contain one or more occurrences of guids that are
+    # substituted with |dynamic_guids|, and then MIDL is run on the substituted
+    # IDL file.
+    generate_idl_from_template(idl_template, dynamic_guids_bytes, idl)
+
   # Unless you have an exact copy of the Google machine were the
   # files were generated, we have to stop here as well.
   # FIXME: Just use the generated files instead of the prebuilt ones,
@@ -199,10 +284,8 @@ def main(arch, gendir, outdir, dynamic_guid, tlb, h, dlldata, iid, proxy, clang,
   return 0
 
   # On Windows, run midl.exe on the input and check that its outputs are
-  # identical to the checked-in outputs (after possibly replacing their main
-  # class guid).
-  tmp_dir = tempfile.mkdtemp()
-  delete_tmp_dir = True
+  # identical to the checked-in outputs (after replacing guids if
+  # |dynamic_guids| is specified).
 
   # Read the environment block from the file. This is stored in the format used
   # by CreateProcess. Drop last 2 NULs, one for list terminator, one for
@@ -214,58 +297,52 @@ def main(arch, gendir, outdir, dynamic_guid, tlb, h, dlldata, iid, proxy, clang,
   preprocessor_options = '-E -nologo -Wno-nonportable-include-path'
   preprocessor_options += ''.join(
       [' ' + flag for flag in flags if flag.startswith('/D')])
-  args = ['midl', '/nologo'] + list(flags) + [
-      '/out', tmp_dir,
-      '/tlb', tlb,
-      '/h', h,
-      '/dlldata', dlldata,
-      '/iid', iid,
-      '/proxy', proxy,
-      '/cpp_cmd', clang,
-      '/cpp_opt', preprocessor_options,
-      idl]
-  try:
-    popen = subprocess.Popen(args, shell=True, env=env_dict,
-                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
-    out, _ = popen.communicate()
-    # Filter junk out of stdout, and write filtered versions. Output we want
-    # to filter is pairs of lines that look like this:
-    # Processing C:\Program Files (x86)\Microsoft SDKs\...\include\objidl.idl
-    # objidl.idl
-    lines = out.decode('utf-8').splitlines()
-    prefixes = ('Processing ', '64 bit Processing ')
-    processing = set(os.path.basename(x)
-                     for x in lines if x.startswith(prefixes))
-    for line in lines:
-      if not line.startswith(prefixes) and line not in processing:
-        print(line)
-    if popen.returncode != 0:
-      return popen.returncode
-
-    for f in os.listdir(tmp_dir):
-      ZapTimestamp(os.path.join(tmp_dir, f))
-
-    # Now compare the output in tmp_dir to the copied-over outputs.
-    diff = filecmp.dircmp(tmp_dir, outdir)
-    if diff.diff_files:
-      print('midl.exe output different from files in %s, see %s' % (outdir,
-                                                                    tmp_dir))
-      for f in diff.diff_files:
-        if f.endswith('.tlb'): continue
-        fromfile = os.path.join(outdir, f)
-        tofile = os.path.join(tmp_dir, f)
-        print(''.join(
-            difflib.unified_diff(
-                io.open(fromfile).readlines(),
-                io.open(tofile).readlines(), fromfile, tofile)))
-      delete_tmp_dir = False
-      print('To rebaseline:')
-      print(r'  copy /y %s\* %s' % (tmp_dir, source))
-      sys.exit(1)
-    return 0
-  finally:
-    if os.path.exists(tmp_dir) and delete_tmp_dir:
-      shutil.rmtree(tmp_dir)
+  args = ['midl', '/nologo'] + list(flags) + (['/tlb', tlb] if tlb else []) + [
+      '/h', h
+  ] + (['/dlldata', dlldata] if dlldata else []) + ['/iid', iid] + (
+      ['/proxy', proxy] if proxy else
+      []) + ['/cpp_cmd', clang, '/cpp_opt', preprocessor_options, idl]
+
+  returncode, midl_output_dir = run_midl(args, env_dict)
+  if returncode != 0:
+    return returncode
+
+  # Now compare the output in midl_output_dir to the copied-over outputs.
+  _, mismatch, errors = filecmp.cmpfiles(midl_output_dir, outdir, common_files)
+  assert not errors
+
+  if mismatch:
+    print('midl.exe output different from files in %s, see %s' %
+          (outdir, midl_output_dir))
+    for f in mismatch:
+      if f.endswith('.tlb'): continue
+      fromfile = os.path.join(outdir, f)
+      tofile = os.path.join(midl_output_dir, f)
+      print(''.join(
+          difflib.unified_diff(
+              io.open(fromfile).readlines(),
+              io.open(tofile).readlines(), fromfile, tofile)))
+
+    if dynamic_guids:
+      # |idl_template| can contain one or more occurrences of guids prefixed
+      # with 'PLACEHOLDER-GUID-'. We first remove the extraneous
+      # 'PLACEHOLDER-GUID-' prefix and then run MIDL on the substituted IDL
+      # file.
+      # No guid substitutions are done at this point, because we want to compile
+      # with the placeholder guids and then instruct the user to copy the output
+      # over to |source| which is typically src\third_party\win_build_output\.
+      # In future runs, the placeholder guids in |source| are replaced with the
+      # guids specified in |dynamic_guids|.
+      generate_idl_from_template(idl_template, None, idl)
+      returncode, midl_output_dir = run_midl(args, env_dict)
+      if returncode != 0:
+        return returncode
+
+    print('To rebaseline:')
+    print(r'  copy /y %s\* %s' % (midl_output_dir, source))
+    return 1
+
+  return 0
 
 
 if __name__ == '__main__':
diff --git a/src/3rdparty/chromium/build/toolchain/win/tool_wrapper.py b/src/3rdparty/chromium/build/toolchain/win/tool_wrapper.py
index 1dffafe3c..a163fa7f9 100644
--- a/src/3rdparty/chromium/build/toolchain/win/tool_wrapper.py
+++ b/src/3rdparty/chromium/build/toolchain/win/tool_wrapper.py
@@ -141,6 +141,7 @@ class WinTool(object):
     # Read output one line at a time as it shows up to avoid OOM failures when
     # GBs of output is produced.
     for line in link.stdout:
+      line = line.decode('utf8')
       if (not line.startswith('   Creating library ') and
           not line.startswith('Generating code') and
           not line.startswith('Finished generating code')):
@@ -158,7 +159,7 @@ class WinTool(object):
     popen = subprocess.Popen(args, shell=True, env=env,
                              stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
     out, _ = popen.communicate()
-    for line in out.splitlines():
+    for line in out.decode('utf8').splitlines():
       if not line.startswith(' Assembling: '):
         print(line)
     return popen.returncode
diff --git a/src/3rdparty/chromium/gpu/config/process_json.py b/src/3rdparty/chromium/gpu/config/process_json.py
index 392f98633..307ff5314 100644
--- a/src/3rdparty/chromium/gpu/config/process_json.py
+++ b/src/3rdparty/chromium/gpu/config/process_json.py
@@ -606,7 +606,7 @@ def write_conditions(entry_id, is_exception, exception_id, entry,
                   'Intel' in driver_vendor)
       assert is_intel, 'Intel driver schema is only for Intel GPUs'
       valid_version = check_intel_driver_version(driver_version['value'])
-      if driver_version.has_key('value2'):
+      if 'value2' in driver_version:
         valid_version = (valid_version and
                          check_intel_driver_version(driver_version['value2']))
       assert valid_version, INTEL_DRIVER_VERSION_SCHEMA
@@ -616,7 +616,7 @@ def write_conditions(entry_id, is_exception, exception_id, entry,
       is_nvidia = (format(vendor_id, '#04x') == '0x10de')
       assert is_nvidia, 'Nvidia driver schema is only for Nvidia GPUs'
       valid_version = check_nvidia_driver_version(driver_version['value'])
-      if driver_version.has_key('value2'):
+      if 'value2' in driver_version:
         valid_version = (valid_version and
                          check_nvidia_driver_version(driver_version['value2']))
       assert valid_version, NVIDIA_DRIVER_VERSION_SCHEMA
diff --git a/src/3rdparty/chromium/third_party/blink/renderer/bindings/scripts/generate_bindings.py b/src/3rdparty/chromium/third_party/blink/renderer/bindings/scripts/generate_bindings.py
index 96a9ebccd..3398a3891 100644
--- a/src/3rdparty/chromium/third_party/blink/renderer/bindings/scripts/generate_bindings.py
+++ b/src/3rdparty/chromium/third_party/blink/renderer/bindings/scripts/generate_bindings.py
@@ -10,6 +10,8 @@ import sys
 
 import web_idl
 import bind_gen
+import multiprocessing as mp
+import os
 
 
 def parse_options():
@@ -99,4 +101,8 @@ def main():
 
 
 if __name__ == '__main__':
+    if sys.platform == 'win32':
+        # for windows, we use python3.exe to specify python3 for most of the part.
+        # but python3.exe is fail to call multiprocess.Pool, so workaround here.
+        mp.set_executable(os.path.join(sys.base_prefix, "python.exe"))
     main()
diff --git a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
index bb1da2f9f..81e46b80b 100644
--- a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
+++ b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
@@ -20,7 +20,7 @@ except ImportError:
 
 
 def read_file(filename):
-    with open(path.normpath(filename), 'rt') as input:
+    with open(path.normpath(filename), 'rt', encoding='utf-8') as input:        
         return input.read()
 
 
diff --git a/src/3rdparty/chromium/third_party/mako/mako/compat.py b/src/3rdparty/chromium/third_party/mako/mako/compat.py
index a3b1fd0ac..2444cad54 100644
--- a/src/3rdparty/chromium/third_party/mako/mako/compat.py
+++ b/src/3rdparty/chromium/third_party/mako/mako/compat.py
@@ -6,7 +6,6 @@
 
 import json  # noqa
 import sys
-import time
 
 py3k = sys.version_info >= (3, 0)
 py33 = sys.version_info >= (3, 3)
@@ -141,11 +140,6 @@ except ImportError:
     else:
         import dummy_thread as thread  # noqa
 
-if win32 or jython:
-    time_func = time.clock
-else:
-    time_func = time.time
-
 try:
     from functools import partial
 except:
diff --git a/src/3rdparty/chromium/third_party/mako/mako/util.py b/src/3rdparty/chromium/third_party/mako/mako/util.py
index 4f1426d23..07f7531fa 100644
--- a/src/3rdparty/chromium/third_party/mako/mako/util.py
+++ b/src/3rdparty/chromium/third_party/mako/mako/util.py
@@ -9,6 +9,7 @@ import collections
 import operator
 import os
 import re
+import timeit
 
 from mako import compat
 
@@ -180,7 +181,7 @@ class LRUCache(dict):
         def __init__(self, key, value):
             self.key = key
             self.value = value
-            self.timestamp = compat.time_func()
+            self.timestamp = timeit.default_timer()
 
         def __repr__(self):
             return repr(self.value)
@@ -191,7 +192,7 @@ class LRUCache(dict):
 
     def __getitem__(self, key):
         item = dict.__getitem__(self, key)
-        item.timestamp = compat.time_func()
+        item.timestamp = timeit.default_timer()
         return item.value
 
     def values(self):
diff --git a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
index 81e46b80b..e9fbeb7ab 100644
--- a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
+++ b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/modular_build.py
@@ -30,7 +30,7 @@ def write_file(filename, content):
     directory = path.dirname(filename)
     if not path.exists(directory):
         os.makedirs(directory)
-    with open(filename, 'wt') as output:
+    with open(filename, 'wt', encoding='utf-8') as output:
         output.write(content)
 
 
diff --git a/src/3rdparty/chromium/tools/json_schema_compiler/idl_schema.py b/src/3rdparty/chromium/tools/json_schema_compiler/idl_schema.py
index 8b39cd6ff..005eabc35 100644
--- a/src/3rdparty/chromium/tools/json_schema_compiler/idl_schema.py
+++ b/src/3rdparty/chromium/tools/json_schema_compiler/idl_schema.py
@@ -552,9 +552,8 @@ def Load(filename):
   Python dictionary in a format that the JSON schema compiler expects to see.
   '''
 
-  f = open(filename, 'r')
-  contents = f.read()
-  f.close()
+  with open(filename, 'rb') as handle:
+    contents = handle.read().decode('utf-8')
 
   return Process(contents, filename)
 
diff --git a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py
index 5cb98e678..ddc514d08 100644
--- a/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py
+++ b/src/3rdparty/chromium/third_party/devtools-frontend/src/scripts/build/build_inspector_overlay.py
@@ -55,7 +55,8 @@ def rollup(input_path, output_path, filename, max_size, rollup_plugin):
             ['--plugin', rollup_plugin],
             stdout=subprocess.PIPE,
             stderr=subprocess.PIPE,
-            text=True)
+            universal_newlines=True,
+            encoding='utf-8')
 
     out, error = rollup_process.communicate()
     if not out:
