From 08f5038bde827716eaf5d75776e2519d8d30fb29 Mon Sep 17 00:00:00 2001
From: George Ruhlmann <george.m.ruhlmann.ctr@us.navy.mil>
Date: Mon, 24 Mar 2025 17:22:43 +0000
Subject: [PATCH 16/29] SIM-18112 Fixed Platforms With No Interpolation

**JIRA Issue:** SIM-18112

**Description:** The updated unit test failed before the code change and now passes after the code change.

**Testing Performed:** Update and ran the unit test.  The steps in the JIRA issue now pass.
---
 SDK/simData/MemoryDataStore.cpp       | 10 ++--
 Testing/SimData/TestInterpolation.cpp | 86 +++++++++++++++++++++++++++
 2 files changed, 91 insertions(+), 5 deletions(-)

diff --git a/SDK/simData/MemoryDataStore.cpp b/SDK/simData/MemoryDataStore.cpp
index 881d2c83..2fc87f5c 100644
--- a/SDK/simData/MemoryDataStore.cpp
+++ b/SDK/simData/MemoryDataStore.cpp
@@ -969,17 +969,17 @@ private:
 
       needToSetToNull_ = true;
 
-      if (interpolateState == InterpolatorState::INTERNAL)
-        update_(time);
-      else if (interpolateState == InterpolatorState::EXTERNAL)
-        entry_->updates()->update(time, ds->interpolator());
-      else
+      if (!isInterpolated)
       {
         entry_->updates()->update(time, updateStartTime_, updateEndTime_);
         // update returns the extended time which might need to be truncated back to the original slice end time
         if (fileMode && !isExtendedPlatform() && (updateEndTime_ > sliceEndTime_))
           updateEndTime_ = sliceEndTime_;
       }
+      else if (interpolateState == InterpolatorState::INTERNAL)
+        update_(time);
+      else
+        entry_->updates()->update(time, ds->interpolator());
     }
 
     /** Called when the slice is modified so that the next call to update will not kick out early */
diff --git a/Testing/SimData/TestInterpolation.cpp b/Testing/SimData/TestInterpolation.cpp
index 1e98781e..e0d6f77f 100644
--- a/Testing/SimData/TestInterpolation.cpp
+++ b/Testing/SimData/TestInterpolation.cpp
@@ -415,6 +415,91 @@ void testInterpolation_linearAngle()
   assertEquals(lslice->isInterpolated(), false);
 }
 
+int testNoInterpolationForIndividualPlatform()
+{
+  int rv = 0;
+
+  simUtil::DataStoreTestHelper testHelper;
+  simData::DataStore* ds = testHelper.dataStore();
+  simData::PlatformPrefs objprefs;
+
+  // setup interpolation
+  simData::LinearInterpolator interpolator;
+  ds->setInterpolator(&interpolator);
+  ds->enableInterpolation(true);
+  assertTrue(ds->isInterpolationEnabled() == true);
+
+  // insert platform
+  uint64_t platId = testHelper.addPlatform();
+
+  // turn off interpolation for an individual platform
+  simData::PlatformPrefs prefs;
+  prefs.set_interpolatepos(false);
+  testHelper.updatePlatformPrefs(prefs, platId);
+
+  // insert data points
+  {
+    simData::DataStore::Transaction t;
+    simData::PlatformUpdate* u = ds->addPlatformUpdate(platId, &t);
+    u->set_time(0.0);
+    u->set_x(simCore::WGS_A + 10.0);
+    u->set_y(11.0);
+    u->set_z(0.0);
+    t.commit();
+  }
+
+  {
+    simData::DataStore::Transaction t;
+    simData::PlatformUpdate* u = ds->addPlatformUpdate(platId, &t);
+    u->set_time(100.0);
+    u->set_x(simCore::WGS_A + 10.0);
+    u->set_y(11.0);
+    u->set_z(100.0);
+    t.commit();
+  }
+
+  const auto* slice = ds->platformUpdateSlice(platId);
+  assertTrue(slice != nullptr);
+
+  // Should be the first point
+  ds->update(0.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 0.0);
+
+  // Should be the first point
+  ds->update(50.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 0.0);
+
+  // Should be second point
+  ds->update(100.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 100.0);
+
+  // Should be the first point
+  ds->update(50.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 0.0);
+
+  // Should be the first point
+  ds->update(0.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 0.0);
+
+  // Should be second point
+  ds->update(100.0);
+  assertTrue(slice->current() != nullptr);
+  assertTrue(slice->current()->has_z());
+  assertEquals(slice->current()->z(), 100.0);
+
+  return rv;
+}
+
 }
 
 int TestInterpolation(int argc, char* argv[])
@@ -427,6 +512,7 @@ int TestInterpolation(int argc, char* argv[])
     testInterpolation_linear(simData::DataStore::InterpolatorState::EXTERNAL);
     testInterpolation_linear(simData::DataStore::InterpolatorState::INTERNAL);
     testInterpolation_linearAngle();
+    testNoInterpolationForIndividualPlatform();
 
     return 0;
   }
-- 
2.47.1.windows.2

