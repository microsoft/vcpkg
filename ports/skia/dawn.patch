diff --git a/BUILD.gn b/BUILD.gn
index b45e6e6f05..bff5f26669 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -15,7 +15,6 @@ if (defined(skia_settings)) {
 }
 
 import("gn/ios.gni")
-import("third_party/dawn/args.gni")
 
 # Skia public API, generally provided by :skia.
 config("skia_public") {
diff --git a/third_party/dawn/BUILD.gn b/third_party/dawn/BUILD.gn
deleted file mode 100644
index e920f0314b..0000000000
--- a/third_party/dawn/BUILD.gn
+++ /dev/null
@@ -1,292 +0,0 @@
-# Copyright 2025 Google LLC.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# These rules invoke Python scripts to build Tint and Dawn using CMake. We use
-# CMake instead of the GN rules because Dawn/Tint's GN rules require Chromium's
-# toolchain, which we, Skia, do not want to have a dependency on.
-# The result is a single static library that can be linked into Skia.
-
-import("//third_party/dawn/args.gni")
-
-if (is_win) {
-  # On Windows, the normal cc/cxx variables are just "clang" and "clang++"
-  # which are not found in the path. CMake needs the full path.
-  if (is_clang) {
-    assert(clang_win != "",
-           "clang_win must be set when is_clang is true on Windows")
-    _cc = "$clang_win/bin/clang-cl.exe"
-    _cxx = "$clang_win/bin/clang-cl.exe"
-  } else {
-    _cc = "$win_vc/Tools/MSVC/$win_toolchain_version/bin/HostX64/$target_cpu/cl.exe"
-    _cxx = "$win_vc/Tools/MSVC/$win_toolchain_version/bin/HostX64/$target_cpu/cl.exe"
-  }
-  _dawn_lib_name = "dawn_combined.lib"
-  _tint_lib_name = "tint_combined.lib"
-} else {
-  _cc = cc
-  _cxx = cxx
-  _dawn_lib_name = "libdawn_combined.a"
-  _tint_lib_name = "libtint_combined.a"
-}
-
-config("tint_api_config") {
-  include_dirs = [
-    "../externals/dawn",
-    "../externals/dawn/include",
-  ]
-
-  defines = [
-    "TINT_BUILD_WGSL_READER=1",
-    "TINT_BUILD_WGSL_WRITER=1",
-  ]
-
-  # The build script produces a static library for tint in the root output directory.
-  lib_dirs = [ root_out_dir ]
-  if (is_win) {
-    libs = [ "tint_combined.lib" ]
-  } else {
-    libs = [ "tint_combined" ]
-  }
-}
-
-# This version of tint is used by skslc, which is used to compile our sksl tests.
-# Thus, we do *not* want to pass in the sanitizer args to this target. When
-# we build the dawn target below, that will build a new version of tint which
-# does use the passed in sanitizer flags.
-action("tint_cmake") {
-  script = "build_tint.py"
-
-  sources = [
-    "build_tint.py",
-    "cmake_utils.py",
-  ]
-
-  # The script will place the final library in this location.
-  outputs = [ "$root_out_dir/${_tint_lib_name}" ]
-
-  # The script also generates a depfile that lists all of Tint's sources. This
-  # allows Ninja to know when to re-run the build script.
-  depfile = "$target_gen_dir/${_tint_lib_name}.d"
-
-  if (get_label_info(current_toolchain, "name") == host_toolchain) {
-    _tint_build_dir = "cmake_tint_host"
-  } else {
-    _tint_build_dir = "cmake_tint"
-  }
-  args = [
-    "--cc=" + _cc,
-    "--cxx=" + _cxx,
-    "--output_path=" + rebase_path(outputs[0], root_build_dir),
-    "--depfile_path=" + rebase_path(depfile, root_build_dir),
-    "--target_os=" + host_os,
-    "--target_cpu=" + host_cpu,
-    "--build_dir=" + _tint_build_dir,
-  ]
-  if (is_clang) {
-    args += [ "--is_clang" ]
-  }
-
-  if (is_debug && !is_win) {
-    # Skia's GN toolchain for Windows doesn't set build_type to be Debug
-    # and if Dawn does, that is a mismatch of _ITERATOR_DEBUG_LEVEL
-    args += [
-      "--build_type=Debug",
-
-      # For performance, set O1 optimization.
-      "--cxx_flags=-O1",
-    ]
-  } else {
-    args += [ "--build_type=Release" ]
-  }
-  if (is_win) {
-    args += [
-      "--win_sdk=" + win_sdk,
-      "--win_sdk_version=" + win_sdk_version,
-      "--win_vc=" + win_vc,
-      "--win_toolchain_version=" + win_toolchain_version,
-    ]
-  }
-
-  # While we don't need to build tint with our sanitizers, we do need to adjust our target version
-  # of tint to be built with libc++ if we have set the rest of Skia to be using that.
-  if (get_label_info(current_toolchain, "name") != host_toolchain) {
-    if (is_linux && sanitize != "") {
-      args += [
-        "--cxx_flags=-stdlib=libc++",
-        "--ld_flags=-stdlib=libc++",
-      ]
-    }
-    if (sanitize == "ASAN") {
-      # See Skia's GN config("no_rtti")
-      args += [ "--enable_rtti" ]
-    }
-  }
-}
-
-group("tint") {
-  deps = [ ":tint_cmake" ]
-
-  public_configs = [ ":tint_api_config" ]
-}
-
-config("dawn_api_config") {
-  include_dirs = [
-    "../externals/dawn",
-    "../externals/dawn/include",
-    "$target_gen_dir/include",
-  ]
-  lib_dirs = [ root_out_dir ]
-  if (is_win) {
-    ldflags = [ "/WHOLEARCHIVE:dawn_combined.lib" ]
-    libs = [
-      "dawn_combined.lib",
-      "onecore.lib",
-      "user32.lib",
-      "delayimp.lib",
-      "dxguid.lib",
-      "libcpmt.lib",
-    ]
-  } else {
-    libs = [ "dawn_combined" ]
-  }
-
-  # https://dawn.googlesource.com/dawn/+/647c352f57aa8a4c2666258455158a36c0c385af/src/dawn/native/BUILD.gn#645
-  if (is_mac || is_ios) {
-    frameworks = [
-      "Foundation.framework",
-      "IOSurface.framework",
-      "IOKit.framework",
-      "Metal.framework",
-      "QuartzCore.framework",
-      "Cocoa.framework",
-    ]
-  }
-}
-
-sanitizer_args = []
-if (sanitize != "") {
-  assert(is_clang, "Need to update GN rules to handle non-Clang Sanitizer")
-  sanitizers = ""
-  if (sanitize == "ASAN") {
-    sanitizers = "undefined,address,float-divide-by-zero"
-    if (is_android) {
-      sanitizers = "address"
-    }
-    if (!is_win) {
-      # See Skia's GN config("no_rtti")
-      sanitizer_args += [ "--enable_rtti" ]
-    }
-  } else if (sanitize == "TSAN") {
-    sanitizers = "thread"
-  } else {
-    assert(false, "Unsupported sanitizer option")
-  }
-
-  _suppressions = rebase_path("../../tools/xsan.supp")
-
-  cxx_flags = [
-    "-fsanitize=$sanitizers",
-    "-fno-sanitize-recover=$sanitizers",
-    "-fsanitize-blacklist=$_suppressions",
-    "-fno-omit-frame-pointer",
-  ]
-  ld_flags = [ "-fsanitize=$sanitizers" ]
-
-  if (is_linux) {
-    cxx_flags += [ "-stdlib=libc++" ]
-    ld_flags += [ "-stdlib=libc++" ]
-  }
-
-  foreach(flag, cxx_flags) {
-    sanitizer_args += [ "--cxx_flags=" + flag ]
-  }
-  foreach(flag, ld_flags) {
-    sanitizer_args += [ "--ld_flags=" + flag ]
-  }
-}
-
-action("dawn_cmake") {
-  script = "build_dawn.py"
-
-  sources = [
-    "build_dawn.py",
-    "cmake_utils.py",
-  ]
-
-  outputs = [ "$root_out_dir/${_dawn_lib_name}" ]
-
-  depfile = "$target_gen_dir/${_dawn_lib_name}.d"
-
-  args = [
-    "--cc=" + _cc,
-    "--cxx=" + _cxx,
-    "--output_path=" + rebase_path(outputs[0], root_build_dir),
-    "--depfile_path=" + rebase_path(depfile, root_build_dir),
-    "--gen_dir=" + rebase_path(target_gen_dir, root_build_dir),
-    "--target_os=" + target_os,
-    "--target_cpu=" + target_cpu,
-    "--build_dir=cmake_dawn",
-  ]
-  if (is_clang) {
-    args += [ "--is_clang" ]
-  }
-  if (is_debug && !is_win) {
-    args += [
-      "--build_type=Debug",
-
-      # For performance, set O1 optimization.
-      "--cxx_flags=-O1",
-    ]
-  } else {
-    args += [ "--build_type=Release" ]
-  }
-  if (is_win) {
-    args += [
-      "--win_sdk=" + win_sdk,
-      "--win_sdk_version=" + win_sdk_version,
-      "--win_vc=" + win_vc,
-      "--win_toolchain_version=" + win_toolchain_version,
-    ]
-  }
-  if (is_android) {
-    args += [
-      "--android_ndk_path=" + ndk,
-      "--android_platform=android-" + ndk_api,
-    ]
-  }
-
-  if (dawn_enable_d3d11) {
-    args += [ "--dawn_enable_d3d11=true" ]
-  } else {
-    args += [ "--dawn_enable_d3d11=false" ]
-  }
-  if (dawn_enable_d3d12) {
-    args += [ "--dawn_enable_d3d12=true" ]
-  } else {
-    args += [ "--dawn_enable_d3d12=false" ]
-  }
-  if (dawn_enable_opengles) {
-    args += [ "--dawn_enable_opengles=true" ]
-  } else {
-    args += [ "--dawn_enable_opengles=false" ]
-  }
-  if (dawn_enable_metal) {
-    args += [ "--dawn_enable_metal=true" ]
-  } else {
-    args += [ "--dawn_enable_metal=false" ]
-  }
-  if (dawn_enable_vulkan) {
-    args += [ "--dawn_enable_vulkan=true" ]
-  } else {
-    args += [ "--dawn_enable_vulkan=false" ]
-  }
-
-  args += sanitizer_args
-}
-
-group("dawn") {
-  public_deps = [ ":dawn_cmake" ]
-
-  public_configs = [ ":dawn_api_config" ]
-}
diff --git a/third_party/dawn/args.gni b/third_party/dawn/args.gni
deleted file mode 100644
index b2c2e707d1..0000000000
--- a/third_party/dawn/args.gni
+++ /dev/null
@@ -1,12 +0,0 @@
-# Copyright 2025 Google LLC.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-declare_args() {
-  # All of these are the same as Dawn's versions for backwards compatibility.
-  dawn_enable_d3d11 = false
-  dawn_enable_d3d12 = is_win
-  dawn_enable_opengles = false
-  dawn_enable_metal = is_mac || is_ios
-  dawn_enable_vulkan = is_linux || is_android
-}
diff --git a/third_party/dawn/build_dawn.py b/third_party/dawn/build_dawn.py
deleted file mode 100644
index e23889e323..0000000000
--- a/third_party/dawn/build_dawn.py
+++ /dev/null
@@ -1,198 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright 2025 Google LLC
-#
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-"""Builds Dawn using CMake.
-
-This script configures and builds Dawn using CMake and Ninja. It then
-discovers all object files for the specified libraries and combines them
-into static archives (.a files) using `ar`. It also copies Dawn's generated
-headers to the location GN expects.
-"""
-
-import argparse
-import os
-import shutil
-import subprocess
-import sys
-
-from cmake_utils import (add_common_cmake_args, combine_into_library,
-                         discover_dependencies, get_cmake_os_cpu,
-                         get_windows_settings, quote_if_needed, write_depfile,
-                         get_third_party_locations)
-
-
-def gn_bool_to_cmake(s):
-  if s.lower() == "true":
-    return "ON"
-  return "OFF"
-
-
-def main():
-  parser = argparse.ArgumentParser(description="Build Dawn using CMake.")
-  add_common_cmake_args(parser)
-  parser.add_argument(
-      "--gen_dir",
-      required=True,
-      help="Directory for generated files (e.g., depfile and headers).")
-  parser.add_argument(
-      "--android_ndk_path", default="", help="Path to the Android NDK.")
-  parser.add_argument(
-      "--android_platform",
-      default="",
-      help="Android platform (e.g., android-29).")
-  parser.add_argument(
-      "--dawn_enable_d3d11", default="false", help="Enable D3D11 backend.")
-  parser.add_argument(
-      "--dawn_enable_d3d12", default="false", help="Enable D3D12 backend.")
-  parser.add_argument(
-      "--dawn_enable_opengles", default="false", help="Enable GLES backend.")
-  parser.add_argument(
-      "--dawn_enable_metal", default="false", help="Enable Metal backend.")
-  parser.add_argument(
-      "--dawn_enable_vulkan", default="false", help="Enable Vulkan backend.")
-  args = parser.parse_args()
-
-  cmake_exe = shutil.which("cmake")
-  if not cmake_exe:
-    print("Error: cmake not found in PATH.")
-    sys.exit(1)
-
-  ninja_exe = shutil.which("ninja")
-  if not ninja_exe:
-    print("Error: ninja not found in PATH.")
-    sys.exit(1)
-
-  target_os, target_cpu = get_cmake_os_cpu(args.target_os, args.target_cpu)
-
-  output_path = args.output_path
-  gen_dir = args.gen_dir
-  # The headers are a dependency for all libraries.
-  # We want to build the other listed dawn components into one big library.
-  build_targets = ["webgpu_headers_gen", "dawn_proc", "dawn_native"]
-  depfile_path = args.depfile_path
-
-  script_dir = os.path.dirname(os.path.realpath(__file__))
-
-  dawn_dir = os.path.join(script_dir, "..", "externals", "dawn")
-  build_dir = args.build_dir
-
-  configure_cmd = [
-      cmake_exe,
-      "-S",
-      dawn_dir,
-      "-B",
-      build_dir,
-      "-G",
-      "Ninja",
-      f"-DCMAKE_MAKE_PROGRAM={ninja_exe}",
-      f"--install-prefix={os.path.abspath(gen_dir)}",
-      f"-DCMAKE_SYSTEM_NAME={target_os}",
-      f"-DCMAKE_SYSTEM_PROCESSOR={target_cpu}",
-      "-DDAWN_BUILD_MONOLITHIC_LIBRARY=OFF",
-      f"-DCMAKE_BUILD_TYPE={args.build_type}",
-      # Explicitly set the C++ standard to avoid issues with CMake's feature
-      # detection for Clang on Windows.
-      "-DCMAKE_CXX_STANDARD=20",
-      "-DCMAKE_CXX_STANDARD_REQUIRED=ON",
-      "-DCMAKE_CXX_EXTENSIONS=OFF",
-      "-DDAWN_FORCE_SYSTEM_COMPONENT_LOAD=ON", # https://g-issues.chromium.org/issues/399358291
-      "-DDAWN_ENABLE_INSTALL=OFF",
-      "-DTINT_ENABLE_INSTALL=OFF",
-      f"-DDAWN_ENABLE_D3D11={gn_bool_to_cmake(args.dawn_enable_d3d11)}",
-      f"-DDAWN_ENABLE_D3D12={gn_bool_to_cmake(args.dawn_enable_d3d12)}",
-      f"-DDAWN_ENABLE_OPENGLES={gn_bool_to_cmake(args.dawn_enable_opengles)}",
-      f"-DDAWN_ENABLE_METAL={gn_bool_to_cmake(args.dawn_enable_metal)}",
-      f"-DDAWN_ENABLE_VULKAN={gn_bool_to_cmake(args.dawn_enable_vulkan)}",
-  ]
-  configure_cmd += get_third_party_locations()
-
-  if args.enable_rtti:
-    configure_cmd.append("-DDAWN_ENABLE_RTTI=ON")
-
-  cxx_flags = args.cxx_flags or []
-  ld_flags = args.ld_flags or []
-
-  if target_os == "Windows":
-    win_cfgs, win_cxx, win_ld = get_windows_settings(args)
-    configure_cmd += win_cfgs
-    cxx_flags += win_cxx
-    ld_flags += win_ld
-
-    # The D3D backend requires the HLSL writer.
-    configure_cmd.append("-DTINT_BUILD_HLSL_WRITER=ON")
-  else:
-    configure_cmd.append("-DTINT_BUILD_HLSL_WRITER=OFF")
-    cxx_flags.append("-w") # Silence warnings
-
-  if cxx_flags:
-    c_cxx_flags_str = " ".join(cxx_flags)
-    # -fno-rtti is not a valid C flag.
-    c_flags = [f for f in cxx_flags if f != "-fno-rtti"]
-    c_flags_str = " ".join(c_flags)
-    configure_cmd.append(f"-DCMAKE_C_FLAGS={c_flags_str}")
-    configure_cmd.append(f"-DCMAKE_CXX_FLAGS={c_cxx_flags_str}")
-
-  if ld_flags:
-    ld_flags_str = " ".join(ld_flags)
-    configure_cmd.append(f"-DCMAKE_EXE_LINKER_FLAGS={ld_flags_str}")
-    configure_cmd.append(f"-DCMAKE_SHARED_LINKER_FLAGS={ld_flags_str}")
-    configure_cmd.append(f"-DCMAKE_MODULE_LINKER_FLAGS={ld_flags_str}")
-
-  if target_os == "Android":
-    configure_cmd.append(f"-DCMAKE_TOOLCHAIN_FILE={args.android_ndk_path}/build/cmake/android.toolchain.cmake")
-    configure_cmd.append(f"-DANDROID_ABI={target_cpu}")
-    configure_cmd.append(f"-DANDROID_PLATFORM={args.android_platform}")
-  else:
-    configure_cmd.append(f"-DCMAKE_C_COMPILER={args.cc.replace(os.sep, '/')}")
-    configure_cmd.append(f"-DCMAKE_CXX_COMPILER={args.cxx.replace(os.sep, '/')}")
-
-  if target_os == "Darwin" or target_os == "iOS":
-    configure_cmd.append(f"-DCMAKE_OSX_ARCHITECTURES={target_cpu}")
-
-  env = os.environ.copy()
-  # Don't write .pyc files, which can cause race conditions when building
-  # tint and dawn in parallel.
-  env["PYTHONDONTWRITEBYTECODE"] = "1"
-
-  if target_os == "Windows":
-    # Set the WINDOWSSDKDIR environment variable to ensure that Dawn's
-    # DetectWindowsSDK function uses the correct, hermetic SDK path.
-    env["WINDOWSSDKDIR"] = args.win_sdk
-
-  print(" ".join(configure_cmd))
-  print("with environment", env)
-  subprocess.run(configure_cmd, check=True, env=env)
-
-  build_cmd = [ninja_exe, "-C", build_dir, "-dkeepdepfile"] + build_targets
-  subprocess.run(build_cmd, check=True, env=env)
-
-  # The install target is broken, so we manually copy the headers.
-  # The headers are located in the build directory in a gen/include folder.
-  # The Skia build expects to find headers in subdirectories of the include path.
-  generated_headers_src = os.path.join(build_dir, "gen", "include")
-  generated_headers_dest = os.path.join(gen_dir, "include")
-
-  if os.path.exists(generated_headers_dest):
-    shutil.rmtree(generated_headers_dest)
-
-  # Copy the contents of the 'dawn' and 'webgpu' directories into the destination.
-  shutil.copytree(
-      os.path.join(generated_headers_src, "dawn"),
-      os.path.join(generated_headers_dest, "dawn"),
-      dirs_exist_ok=True)
-  shutil.copytree(
-      os.path.join(generated_headers_src, "webgpu"),
-      os.path.join(generated_headers_dest, "webgpu"),
-      dirs_exist_ok=True)
-
-  dependencies, object_files = discover_dependencies(build_dir, build_targets)
-  write_depfile(output_path, depfile_path, dependencies)
-
-  combine_into_library(args, output_path, build_dir, target_os, object_files)
-
-if __name__ == "__main__":
-  main()
diff --git a/third_party/dawn/build_tint.py b/third_party/dawn/build_tint.py
deleted file mode 100644
index b2a6253455..0000000000
--- a/third_party/dawn/build_tint.py
+++ /dev/null
@@ -1,136 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright 2025 Google LLC
-#
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-"""Builds Tint using CMake.
-
-This script configures and builds Tint using CMake and Ninja. It then
-discovers all object files for the specified libraries and combines them
-into a static archive (.a [Linux/Mac] or .lib [Windows]).
-"""
-
-import argparse
-import os
-import shutil
-import subprocess
-import sys
-
-from cmake_utils import (
-    add_common_cmake_args, combine_into_library, discover_dependencies,
-    get_cmake_os_cpu, get_windows_settings, quote_if_needed, write_depfile,
-    get_third_party_locations)
-
-
-def main():
-  parser = argparse.ArgumentParser(description="Build Tint using CMake.")
-  add_common_cmake_args(parser)
-  args = parser.parse_args()
-
-  target_os, target_cpu = get_cmake_os_cpu(args.target_os, args.target_cpu)
-
-  output_path = args.output_path
-  depfile_path = args.depfile_path
-  script_dir = os.path.dirname(os.path.realpath(__file__))
-  dawn_dir = os.path.join(script_dir, "..", "externals", "dawn")
-
-  # The build can be invoked in parallel for different toolchains, so we use
-  # a short, unique build directory.
-  build_dir = args.build_dir
-
-  cmake_exe = shutil.which("cmake")
-  if not cmake_exe:
-    print("Error: cmake not found in PATH.")
-    sys.exit(1)
-
-  ninja_exe = shutil.which("ninja")
-  if not ninja_exe:
-    print("Error: ninja not found in PATH.")
-    sys.exit(1)
-
-  # Configure the project using CMake. Tint is a part of Dawn.
-  # https://github.com/google/dawn/blob/main/docs/quickstart-cmake.md
-  configure_cmd = [
-      cmake_exe,
-      "-S",
-      dawn_dir,
-      "-B",
-      build_dir,
-      f"-DCMAKE_C_COMPILER={args.cc.replace(os.sep, '/')}",
-      f"-DCMAKE_CXX_COMPILER={args.cxx.replace(os.sep, '/')}",
-      f"-DCMAKE_SYSTEM_NAME={target_os}",
-      f"-DCMAKE_SYSTEM_PROCESSOR={target_cpu}",
-      # This is handled by GN
-      "-DDAWN_FETCH_DEPENDENCIES=OFF",
-      "-DDAWN_ENABLE_INSTALL=OFF",
-      f"-DCMAKE_BUILD_TYPE={args.build_type}",
-      # skslc needs WGSL support.
-      "-DTINT_BUILD_WGSL_READER=ON",
-      "-DTINT_BUILD_WGSL_WRITER=ON",
-      "-DTINT_ENABLE_INSTALL=ON",
-      # Use Ninja for faster builds.
-      "-G",
-      "Ninja",
-      f"-DCMAKE_MAKE_PROGRAM={ninja_exe}",
-      "-DDAWN_ENABLE_D3D11=OFF",
-      "-DDAWN_ENABLE_D3D12=OFF",
-      "-DDAWN_ENABLE_METAL=OFF",
-      "-DDAWN_ENABLE_NULL=OFF",
-      "-DDAWN_ENABLE_DESKTOP_GL=OFF",
-      "-DDAWN_ENABLE_OPENGLES=OFF",
-      "-DDAWN_ENABLE_VULKAN=OFF",
-  ]
-  configure_cmd += get_third_party_locations()
-  if args.enable_rtti:
-    configure_cmd.append("-DDAWN_ENABLE_RTTI=ON")
-
-  cxx_flags = args.cxx_flags or []
-  ld_flags = args.ld_flags or []
-
-  if target_os == "Windows":
-    win_cfgs, win_cxx, win_ld = get_windows_settings(args)
-    configure_cmd += win_cfgs
-    cxx_flags += win_cxx
-    ld_flags += win_ld
-
-  if cxx_flags:
-    c_cxx_flags_str = " ".join(cxx_flags)
-    configure_cmd.append(f"-DCMAKE_CXX_FLAGS={c_cxx_flags_str}")
-
-  if ld_flags:
-    ld_flags_str = " ".join(ld_flags)
-    configure_cmd.append(f"-DCMAKE_EXE_LINKER_FLAGS={ld_flags_str}")
-    configure_cmd.append(f"-DCMAKE_SHARED_LINKER_FLAGS={ld_flags_str}")
-    configure_cmd.append(f"-DCMAKE_MODULE_LINKER_FLAGS={ld_flags_str}")
-
-  # Set PYTHONPATH to include Dawn's third_party directory. This is needed
-  # for the generator scripts to find jinja2 and markupsafe as packages.
-  third_party_dir = os.path.abspath(os.path.join(dawn_dir, "third_party"))
-  env = os.environ.copy()
-  env["PYTHONPATH"] = third_party_dir
-  # Don't write .pyc files, which can cause race conditions when building
-  # tint and dawn in parallel.
-  env["PYTHONDONTWRITEBYTECODE"] = "1"
-
-  subprocess.run(configure_cmd, check=True, env=env)
-
-  # These tint targets (and their deps) are what Skia needs to build
-  tint_targets = ["tint_api", "tint_lang_wgsl_reader", "tint_lang_wgsl_writer"]
-
-  build_cmd = [ninja_exe, "-C", build_dir, "-dkeepdepfile"] + tint_targets
-  subprocess.run(build_cmd, check=True, env=env)
-
-  dependencies, object_files = discover_dependencies(build_dir, tint_targets)
-  # Generate the depfile. This lists all source files that the Tint library
-  # depends on. This allows GN to know when to re-run this script.
-  write_depfile(output_path, depfile_path, dependencies)
-
-  # After building, Tint consists of many small object files. For easier
-  # consumption by GN, we combine them into a single archive using ar.
-  combine_into_library(args, output_path, build_dir, target_os, object_files)
-
-
-if __name__ == "__main__":
-  main()
diff --git a/third_party/dawn/cmake_utils.py b/third_party/dawn/cmake_utils.py
deleted file mode 100644
index ed4c89da34..0000000000
--- a/third_party/dawn/cmake_utils.py
+++ /dev/null
@@ -1,413 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright 2025 Google LLC
-#
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-import argparse
-import hashlib
-import os
-import shutil
-import subprocess
-import sys
-
-
-def add_common_cmake_args(parser):
-  """Adds common arguments used for building with CMake."""
-  print(f"Running with Python executable: {sys.executable}")
-
-  parser.add_argument("--cc", required=True, help="Path to the C compiler.")
-  parser.add_argument("--cxx", required=True, help="Path to the C++ compiler.")
-  parser.add_argument(
-      "--cxx_flags",
-      default=[],
-      action="append",
-      help="C++ compiler flags. Can be specified multiple times.")
-  parser.add_argument(
-      "--ld_flags",
-      default=[],
-      action="append",
-      help="Linker flags. Can be specified multiple times.")
-  parser.add_argument(
-      "--output_path", required=True, help="Path to the output library.")
-  parser.add_argument(
-      "--depfile_path", required=True, help="Path to the depfile to generate.")
-  parser.add_argument(
-      "--target_os", required=True, help="Target OS for cross-compilation.")
-  parser.add_argument(
-      "--target_cpu", required=True, help="Target CPU for cross-compilation.")
-  parser.add_argument(
-      "--win_sdk", default="", help="Path to the Windows SDK.")
-  parser.add_argument(
-      "--win_sdk_version", default="", help="Version of the Windows SDK.")
-  parser.add_argument(
-      "--win_vc", default="", help="Path to Visual C++.")
-  parser.add_argument(
-      "--win_toolchain_version",
-      default="",
-      help="Version of the MSVC toolchain.")
-  parser.add_argument(
-      "--build_type", default="Release", help="CMake build type.")
-  parser.add_argument(
-      "--build_dir",
-      required=True,
-      help="A short name for the build directory.")
-  parser.add_argument("--is_clang", action=argparse.BooleanOptionalAction)
-  parser.add_argument(
-      "--enable_rtti", action=argparse.BooleanOptionalAction, help="Enable RTTI.")
-
-def add_next_batch_to_command(base_cmd, workset):
-  if sys.platform != 'win32':
-    batch = list(workset)
-    return base_cmd + batch, batch
-  # Windows has a limit of about 8100 characters on command line commands.
-  # Thus we batch our commands to fit under this. 100 is usually short enough
-  # but with fluctuations on the order returned by ninja and set(), this can
-  # still sometimes be too long, so we ensure we don't go over the limit.
-  BATCH_SIZE = 100
-  batch = list(workset)[:BATCH_SIZE]
-  cmd = base_cmd + batch
-
-  while len(' '.join(cmd)) > 8100:
-    assert(len(batch) > 1)
-    batch.pop()
-    cmd = base_cmd + batch
-
-  return cmd, batch
-
-def discover_dependencies(build_dir, targets):
-  """Runs ninja -tinputs recursively to discover all targets, then uses
-  ninja -tdeps to get all source files and object files for those targets.
-  Returns a tuple of (list of source files, list of object files)."""
-  # The worklist contains ninja targets we need to find the inputs for.
-  worklist = set(targets)
-  # We keep track of all ninja targets we've ever seen to avoid cycles and
-  # redundant processing.
-  seen_targets = set(targets)
-
-  source_files = set()
-
-  ninja = shutil.which("ninja");
-  if not ninja:
-    print("Error: ninja not found in PATH.")
-    sys.exit(1)
-
-  while len(worklist) > 0:
-    cmd, current_batch = add_next_batch_to_command([ninja, "-C", build_dir, "-tinputs"],
-                                                   worklist)
-    worklist = worklist.difference(current_batch)
-
-    inputs = subprocess.check_output(cmd).decode("utf-8").splitlines()
-    # inputs looks like:
-    #   /home/user/skia/third_party/externals/dawn/src/tint/utils/text/styled_text_theme.cc
-    #   /home/user/skia/third_party/externals/dawn/src/tint/utils/text/unicode.cc
-    #   cmake_object_order_depends_target_tint_api_common
-    #   cmake_object_order_depends_target_tint_lang_core
-    #   src/tint/CMakeFiles/tint_api_common.dir/api/common/vertex_pulling_config.cc.o
-    #   src/tint/CMakeFiles/tint_lang_core.dir/lang/core/binary_op.cc.o
-    #   src/tint/libtint_api_common.a
-    #   src/tint/libtint_lang_core.a
-    # Some of these are files (which we can add to the source file list), some are more targets,
-    # which we should recursively get targets for to make sure we have the whole dependency graph.
-    for line in inputs:
-      line = line.strip()
-      if os.path.isabs(line):
-        # Absolute paths are source files.
-        source_files.add(line)
-        continue
-      if line not in seen_targets:
-        worklist.add(line)
-        seen_targets.add(line)
-
-  object_files = []
-  for target in seen_targets:
-    if target.endswith(".o") or target.endswith(".obj"):
-      object_files.append(target)
-  object_files.sort()
-
-  # Now that we have all the targets and some of the source files, get the dependencies for them.
-  abs_build_dir = os.path.abspath(build_dir)
-
-  worklist = set(seen_targets)
-  while len(worklist) > 0:
-    cmd, current_batch = add_next_batch_to_command([ninja, "-C", build_dir, "-tdeps"],
-                                                   worklist)
-    worklist = worklist.difference(current_batch)
-
-    output = subprocess.check_output(cmd).decode("utf-8").splitlines()
-    # When a target has deps, which are read from the .d files generated from the "-dkeepdepfile
-    # option earlier, the ninja command outputs something like this:
-    #   third_party/spirv-tools/source/opt/CMakeFiles/SPIRV-Tools-opt.dir/eliminate_dead_functions_util.cpp.o: #deps 408, deps mtime 1755004530688332629 (VALID)
-    #       /home/user/skia/third_party/externals/dawn/third_party/spirv-tools/src/source/opt/eliminate_dead_functions_util.cpp
-    #       /usr/include/stdc-predef.h
-    #       /home/user/skia/third_party/externals/dawn/third_party/spirv-tools/src/source/opt/eliminate_dead_functions_util.h
-    #       /home/user/skia/third_party/externals/dawn/third_party/spirv-tools/src/source/opt/ir_context.h
-    #       /usr/include/c++/14/algorithm
-    #   These can sometimes be relative files (on Windows) with the base path being the build_dir
-    #   src/tint/CMakeFiles/tint_lang_wgsl_sem.dir/lang/wgsl/sem/variable.cc.obj: #deps 300, deps mtime 7816349331123163 (VALID)
-    #     ../../../../../cipd/clang_win/lib/clang/18/include/x86gprintrin.h
-    #     ../../../../../cipd/win_toolchain/VC/Tools/MSVC/14.39.33519/include/__msvc_bit_utils.hpp
-    #     ../../../../../cipd/win_toolchain/VC/Tools/MSVC/14.39.33519/include/cctype
-    #     ../../../../../cipd/win_toolchain/win_sdk/Include/10.0.22621.0/ucrt/wchar.h
-    #     ../../../third_party/externals/dawn/src/tint/api/common/binding_point.h
-    #     ../../../third_party/externals/dawn/src/tint/lang/core/constant/clone_context.h
-    # If there's not a match, it's a simple message like:
-    # src/tint/libtint_utils_text_generator.a: deps not found
-    # We want to aggregate all the indented files
-    for line in output:
-      if not line.startswith("  ") or "deps not found" in line:
-        continue
-      line = line.strip()
-      if os.path.isabs(line):
-        source_files.add(line)
-      else:
-        dep = os.path.normpath(os.path.join(abs_build_dir, line))
-        source_files.add(dep)
-
-  result = list(source_files)
-  result.sort()
-  return result, object_files
-
-
-def write_depfile(output_path, depfile_path, dependencies):
-  """Generates a .d file that lists all discovered source files as
-  dependencies for the given output library."""
-  os.makedirs(os.path.dirname(depfile_path), exist_ok=True)
-  with open(depfile_path, "w") as f:
-    f.write(f"{output_path}:")
-    # Make sure to use forward slashes for paths in the depfile, even on
-    # Windows, for consistency.
-    for dep in dependencies:
-      f.write(" \\\n" + dep.replace("\\", "/"))
-    f.write("\n")
-
-
-def quote_if_needed(path):
-  """Adds quotes to a path if it contains spaces."""
-  if " " in path:
-    return f'"{path}"'
-  return path
-
-
-def copy_if_changed(src, dest):
-  """Copies the file from src to dest if dest doesn't exist or if the
-  contents of src and dest are different."""
-  if os.path.exists(dest):
-    src_hash = hashlib.sha256(open(src, "rb").read()).hexdigest()
-    dest_hash = hashlib.sha256(open(dest, "rb").read()).hexdigest()
-    if src_hash == dest_hash:
-      # The files are identical, no need to copy.
-      return
-
-  # Either the destination does not exist or it is different.
-  shutil.copyfile(src, dest)
-  os.chmod(dest, 0o755)
-
-
-def get_cmake_os_cpu(os, cpu):
-  # https://stackoverflow.com/a/70498851
-  os = os.lower().strip()
-  cpu = cpu.lower().strip()
-  if os == "android":
-    target_cpu_map = {
-      "arm": "armeabi-v7a",
-      "arm64": "arm64-v8a",
-      "x64": "x86_64",
-      "x86": "x86",
-    }
-    return "Android", target_cpu_map[cpu]
-
-  if os == "linux":
-    target_cpu_map = {
-      "arm": "arm",
-      "arm64": "aarch64",
-      "x64": "x86_64",
-      "x86": "i686",
-    }
-    return "Linux", target_cpu_map[cpu]
-
-  if os == "mac":
-    target_cpu_map = {
-      "arm64": "arm64",
-      "x64": "x86_64",
-    }
-    return "Darwin", target_cpu_map[cpu]
-
-  if os == "win":
-    target_cpu_map = {
-      "arm64": "ARM64",
-      "x64": "AMD64",
-    }
-    return "Windows", target_cpu_map[cpu]
-
-  print("Unsupported OS")
-  sys.exit(1)
-
-
-def get_windows_settings(args):
-  """The Windows toolchain requires a lot of setup for cmake to use it.
-     This encapsulates all that setup.
-  """
-
-  assert(args.win_vc)
-  assert(args.win_sdk)
-  assert(args.win_sdk_version)
-
-  win_cfgs, win_cxx, win_ld  = [], [], []
-
-  # Set the Windows SDK version for CMake.
-  win_cfgs.append(
-      f"-DCMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION={args.win_sdk_version}")
-
-  # Explicitly tell CMake where to find the Resource Compiler, Manifest Tool, and Archiver.
-  rc_exe_path = os.path.join(args.win_sdk, "bin", args.win_sdk_version,
-                             args.target_cpu, "rc.exe")
-  win_cfgs.append(f"-DCMAKE_RC_COMPILER={rc_exe_path.replace(os.sep, '/')}")
-  mt_exe_path = os.path.join(args.win_sdk, "bin", args.win_sdk_version,
-                             args.target_cpu, "mt.exe")
-  win_cfgs.append(f"-DCMAKE_MT={mt_exe_path.replace(os.sep, '/')}")
-
-  ar_exe_path = os.path.join(args.win_vc, "Tools", "MSVC",
-                             args.win_toolchain_version, "bin", "Hostx64",
-                             args.target_cpu, "lib.exe")
-  win_cfgs.append(f"-DCMAKE_AR={ar_exe_path.replace(os.sep, '/')}")
-
-  # On Windows, we need to explicitly tell clang where to find the toolchain
-  # headers and libraries.
-  um_lib_path = os.path.join(args.win_sdk, "Lib", args.win_sdk_version, "um", args.target_cpu)
-  ucrt_lib_path = os.path.join(args.win_sdk, "Lib", args.win_sdk_version, "ucrt", args.target_cpu)
-  msvc_lib_path = os.path.join(args.win_vc, "Tools", "MSVC", args.win_toolchain_version, "lib", args.target_cpu)
-
-  win_ld += [
-    f"/LIBPATH:{quote_if_needed(um_lib_path.replace(os.sep, '/'))}",
-    f"/LIBPATH:{quote_if_needed(ucrt_lib_path.replace(os.sep, '/'))}",
-    f"/LIBPATH:{quote_if_needed(msvc_lib_path.replace(os.sep, '/'))}",
-  ]
-
-  # Skia builds with exceptions and RTTI disabled so we must also build Dawn that way.
-  win_cxx += [
-      "-D_HAS_EXCEPTIONS=0",
-      "/GR-",
-      "/w",  # Dawn's warnings are noisy
-  ]
-
-  # Skia uses a hermetic toolchain, so we need to tell clang where to
-  # find the MSVC headers and libraries. If we pass the MSVC style flags (/I)
-  # to clang, then abseil fails to compile with errors about using a
-  # reinterpret_cast in a static_assert.
-  if args.is_clang:
-    win_cxx += [
-        "-imsvc",
-        quote_if_needed(os.path.join(args.win_vc, "Tools", "MSVC", args.win_toolchain_version, "include")),
-        "-imsvc",
-        quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "ucrt")),
-        "-imsvc",
-        quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "shared")),
-        "-imsvc",
-        quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "um")),
-        "-imsvc",
-        quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "winrt")),
-    ]
-  else:
-    win_cxx += [
-        "/I" + quote_if_needed(os.path.join(args.win_vc, "Tools", "MSVC", args.win_toolchain_version, "include")),
-        "/I" + quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "ucrt")),
-        "/I" + quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "shared")),
-        "/I" + quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "um")),
-        "/I" + quote_if_needed(os.path.join(args.win_sdk, "Include", args.win_sdk_version, "winrt")),
-    ]
-
-  # We want to build Dawn (and its dependencies) with /MT so we can statically
-  # link it into Skia.
-  win_cfgs.append("-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded")
-  win_cfgs.append("-DABSL_MSVC_STATIC_RUNTIME=ON")
-
-  return win_cfgs, win_cxx, win_ld
-
-
-def combine_into_library(args, output_path, build_dir, target_os, object_files):
-  """Combine all the object files into a single .a/.lib file so it's easier to
-     give this to GN."""
-
-  # Delete generated library if it exists already (otherwise ar sometimes chokes)
-  lib_name = os.path.basename(output_path)
-  gen_library_path = os.path.join(build_dir, lib_name)
-  if os.path.exists(gen_library_path):
-    os.remove(gen_library_path)
-
-  assert len(object_files) > 0
-  # Use ar/lib to join all the object files that comprise the necessary
-  # libraries and any transitive dependencies into one .a file.
-  if target_os == "Windows":
-    # On Windows, we use lld-link.exe for clang, and lib.exe for MSVC.
-    if args.is_clang:
-        linker_exe = os.path.join(os.path.dirname(args.cc), "lld-link.exe")
-    else:
-        # We can't just use ar.exe because it is not shipped with MSVC.
-        # We must use lib.exe, which has a different command line.
-        linker_exe = os.path.join(args.win_vc, "Tools", "MSVC",
-                               args.win_toolchain_version, "bin", "Hostx64",
-                               args.target_cpu, "lib.exe")
-    # The command line can be too long, so we use a response file.
-    response_file_name = "objects.rsp"
-    response_file_path = os.path.join(build_dir, response_file_name)
-    with open(response_file_path, "w") as f:
-      for obj in object_files:
-        f.write(f'"{obj}"\n')
-    combine_obj_cmd = [
-        linker_exe, "/LIB", f"/OUT:{lib_name}", f"@{response_file_name}"
-    ]
-  else:
-    combine_obj_cmd = ["ar", "rcs", lib_name] + object_files
-  subprocess.run(combine_obj_cmd, cwd=build_dir, check=True)
-
-  copy_if_changed(gen_library_path, os.path.join(os.getcwd(), output_path))
-
-
-
-def get_third_party_locations():
-  """Return CMake configure arguments to point to or disable third_party deps"""
-  def verify_and_get(subpath):
-    third_party_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), "..", "externals")
-    third_party_dir = os.path.abspath(third_party_dir)
-    path = os.path.join(third_party_dir, subpath)
-    if not os.path.exists(path):
-      print(f"Third party path {path} not found - did you sync your DEPS?")
-      sys.exit(1)
-    return path
-
-  return [
-    # Actually downloading the 3p repos is handled by DEPS / tools/git-sync-deps
-    "-DDAWN_FETCH_DEPENDENCIES=OFF",
-    # Necessary 3p deps
-    f"-DDAWN_ABSEIL_DIR={verify_and_get('abseil-cpp')}",
-    f"-DDAWN_EGL_REGISTRY_DIR={verify_and_get('egl-registry')}",
-    f"-DDAWN_GLSLANG_DIR={verify_and_get('glslang')}",
-    f"-DDAWN_JINJA2_DIR={verify_and_get('jinja2')}",
-    f"-DDAWN_MARKUPSAFE_DIR={verify_and_get('markupsafe')}",
-    f"-DDAWN_OPENGL_REGISTRY_DIR={verify_and_get('opengl-registry')}",
-    f"-DDAWN_SPIRV_HEADERS_DIR={verify_and_get('spirv-headers')}",
-    f"-DDAWN_SPIRV_TOOLS_DIR={verify_and_get('spirv-tools')}",
-    f"-DDAWN_VULKAN_HEADERS_DIR={verify_and_get('vulkan-headers')}",
-    f"-DDAWN_VULKAN_UTILITY_LIBRARIES_DIR={verify_and_get('vulkan-utility-libraries')}",
-    f"-DDAWN_WEBGPU_HEADERS_DIR={verify_and_get('webgpu-headers')}",
-    f"-DDAWN_SWIFTSHADER_DIR={verify_and_get('swiftshader')}",
-
-    # Disable unnecessary deps
-    "-DDAWN_BUILD_BENCHMARKS=OFF",
-    "-DDAWN_BUILD_PROTOBUF=OFF",
-    "-DDAWN_BUILD_SAMPLES=OFF",
-    "-DDAWN_BUILD_TESTS=OFF",
-    "-DDAWN_USE_GLFW=OFF",
-    "-DTINT_BUILD_BENCHMARKS=OFF",
-    "-DTINT_BUILD_IR_BINARY=OFF",
-    "-DTINT_BUILD_TESTS=OFF",
-    "-DDAWN_USE_X11=OFF",
-
-    # Explicitly mark third_party deps as not here to make debugging easier
-    "-DDAWN_EMDAWNWEBGPU_DIR=NOT_SYNCED_BY_SKIA",
-    "-DDAWN_GLFW_DIR=NOT_SYNCED_BY_SKIA",
-    "-DDAWN_LPM_DIR=NOT_SYNCED_BY_SKIA",
-    "-DDAWN_PROTOBUF_DIR=NOT_SYNCED_BY_SKIA",
-  ]
diff --git a/third_party/dawn/fetch_and_stamp.py b/third_party/dawn/fetch_and_stamp.py
deleted file mode 100644
index d139ed1b43..0000000000
--- a/third_party/dawn/fetch_and_stamp.py
+++ /dev/null
@@ -1,34 +0,0 @@
-#!/usr/bin/env python3
-#
-# Copyright 2025 Google LLC
-#
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-#
-
-import argparse
-import os
-import subprocess
-import sys
-
-def main():
-  parser = argparse.ArgumentParser()
-  parser.add_argument("--stamp_path", required=True, help="Path to the output stamp file.")
-  parser.add_argument("--depfile_path", required=True, help="Path to the output depfile.")
-  parser.add_argument("--dawn_dir", required=True, help="Path to the Dawn checkout.")
-  args = parser.parse_args()
-
-  fetch_script = os.path.join(args.dawn_dir, "tools", "fetch_dawn_dependencies.py")
-  subprocess.check_call([sys.executable, fetch_script, "--directory=" + args.dawn_dir])
-
-  # Create the stamp file.
-  with open(args.stamp_path, "w") as f:
-    f.write("done")
-
-  # If the DEPS file changes, GN will know to re-run this script and update the dependencies.
-  deps_file = os.path.join(args.dawn_dir, "DEPS")
-  with open(args.depfile_path, "w") as f:
-    f.write(f"{args.stamp_path}: {deps_file}\n")
-
-if __name__ == "__main__":
-  main()
diff --git a/tools/window/BUILD.gn b/tools/window/BUILD.gn
index b532490b97..06f397a28c 100644
--- a/tools/window/BUILD.gn
+++ b/tools/window/BUILD.gn
@@ -4,7 +4,6 @@
 # found in the LICENSE file.
 
 import("../../gn/skia.gni")
-import("../../third_party/dawn/args.gni")
 
 config("public_config") {
   defines = []
