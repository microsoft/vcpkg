diff --git a/cmake/inputs/Config.cmake.in b/cmake/inputs/Config.cmake.in
index 7e4b2bd..c366522 100644
--- a/cmake/inputs/Config.cmake.in
+++ b/cmake/inputs/Config.cmake.in
@@ -14,6 +14,7 @@
 if(NOT @BUILD_SHARED_LIBS@) # NOT BUILD_SHARED_LIBS
   include(CMakeFindDependencyMacro)
   find_dependency(Threads)
+  find_dependency(Blosc2)
   find_dependency(BZip2)
   find_dependency(lz4)
   find_dependency(spdlog)
diff --git a/cmake/Modules/FindLZ4.cmake b/cmake/Modules/FindLZ4.cmake
index cad9f69..e6678dd 100644
--- a/cmake/Modules/FindLZ4.cmake
+++ b/cmake/Modules/FindLZ4.cmake
@@ -43,30 +43,30 @@ if (lz4_FOUND)
   if(TARGET LZ4::lz4 AND NOT TARGET lz4::lz4)
     add_library(lz4::lz4 ALIAS LZ4::lz4)
   endif()
-  return()
-endif()
-
-# Package not found, search in system paths.
-find_library(LZ4_LIBRARIES
-  NAMES
-    lz4 liblz4
-  PATH_SUFFIXES lib bin
-)
-
-find_path(LZ4_INCLUDE_DIR
-  NAMES lz4.h
-  PATH_SUFFIXES include
-)
+  set(LZ4_FOUND TRUE)
+else()
+  # Package not found, search in system paths.
+  find_library(LZ4_LIBRARIES
+    NAMES
+      lz4 liblz4
+    PATH_SUFFIXES lib bin
+  )
 
-include(FindPackageHandleStandardArgs)
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(LZ4
-  REQUIRED_VARS LZ4_LIBRARIES LZ4_INCLUDE_DIR
-)
+  find_path(LZ4_INCLUDE_DIR
+    NAMES lz4.h
+    PATH_SUFFIXES include
+  )
 
-if (LZ4_FOUND AND NOT TARGET lz4::lz4)
-  add_library(lz4::lz4 UNKNOWN IMPORTED)
-  set_target_properties(lz4::lz4 PROPERTIES
-    IMPORTED_LOCATION "${LZ4_LIBRARIES}"
-    INTERFACE_INCLUDE_DIRECTORIES "${LZ4_INCLUDE_DIR}"
+  include(FindPackageHandleStandardArgs)
+  FIND_PACKAGE_HANDLE_STANDARD_ARGS(LZ4
+    REQUIRED_VARS LZ4_LIBRARIES LZ4_INCLUDE_DIR
   )
+
+  if (LZ4_FOUND AND NOT TARGET lz4::lz4)
+    add_library(lz4::lz4 UNKNOWN IMPORTED)
+    set_target_properties(lz4::lz4 PROPERTIES
+      IMPORTED_LOCATION "${LZ4_LIBRARIES}"
+      INTERFACE_INCLUDE_DIRECTORIES "${LZ4_INCLUDE_DIR}"
+    )
+  endif()
 endif()
diff --git a/tiledb/CMakeLists.txt b/tiledb/CMakeLists.txt
index 81ef162..e06410d 100644
--- a/tiledb/CMakeLists.txt
+++ b/tiledb/CMakeLists.txt
@@ -389,37 +389,12 @@ if (TILEDB_SERIALIZATION)
 
 endif()
 
-# 'External' source files included in the source tree.
-list(APPEND TILEDB_EXTERNALS_INCLUDE_DIRS
-  "${CMAKE_CURRENT_SOURCE_DIR}/../external/include"
-  "${CMAKE_CURRENT_SOURCE_DIR}/../external/include/bitshuffle"
-  "${CMAKE_CURRENT_SOURCE_DIR}/../external/include/blosc"
-)
-list(APPEND TILEDB_EXTERNALS_SOURCES
-  ${CMAKE_CURRENT_SOURCE_DIR}/../external/src/bitshuffle/iochain.cc
-  ${CMAKE_CURRENT_SOURCE_DIR}/../external/src/bitshuffle/bitshuffle_core.cc
-)
-
-#
-# Delegate configuration and detection of platform-specific code generation to
-# the subdirectory. For why the separation isn't clean, see comments there.
-#
-add_subdirectory(
-  ${CMAKE_CURRENT_SOURCE_DIR}/../external/blosc
-  ${CMAKE_CURRENT_BINARY_DIR}/../external/blosc)
-list(APPEND TILEDB_EXTERNALS_INCLUDE_DIRS ${TileDB_blosc_INCLUDE_DIRS})
-list(APPEND TILEDB_EXTERNALS_SOURCES ${TileDB_blosc_SOURCES})
-set_source_files_properties(
-  ${TileDB_blosc_SOURCES}
-  PROPERTIES COMPILE_OPTIONS "${TileDB_blosc_COMPILE_OPTIONS}")
-
 ############################################################
 # Build core objects as a reusable object library
 ############################################################
 
 add_library(TILEDB_CORE_OBJECTS OBJECT
     ${TILEDB_CORE_SOURCES}
-    ${TILEDB_EXTERNALS_SOURCES}
 )
 
 # List of libraries to be linked to TILEDB_CORE_OBJECTS.
@@ -450,7 +425,6 @@ target_include_directories(TILEDB_CORE_OBJECTS
   PRIVATE
     "${TILEDB_CORE_INCLUDE_DIR}"
     "${TILEDB_CORE_INCLUDE_DIR}/tiledb/sm/c_api"
-    "${TILEDB_EXTERNALS_INCLUDE_DIRS}"
 	# to pickup <build_dir>/tiledb for capnp gen'd files
     "${CMAKE_CURRENT_BINARY_DIR}/.."
 )
@@ -498,9 +472,6 @@ add_library(TILEDB_CORE_OBJECTS_ILIB INTERFACE)
 # object store definitions
 target_link_libraries(TILEDB_CORE_OBJECTS_ILIB INTERFACE configuration_definitions)
 
-# blosc link dependencies
-target_link_libraries(TILEDB_CORE_OBJECTS_ILIB INTERFACE ${TileDB_blosc_LINK_OPTIONS})
-
 # Find OpenSSL first in case it's needed for S3 or Azure
 if (NOT WIN32)
   find_package(OpenSSL REQUIRED)
@@ -570,6 +541,7 @@ endif()
 # Required dependencies. These come last as any prior dependencies relying on
 # these must be listed first for Linux. E.g. AWSSDK and Curl depend on Zlib,
 # which is installed here.
+find_package(Blosc2 CONFIG REQUIRED)
 find_package(BZip2 REQUIRED)
 find_package(LZ4 MODULE REQUIRED)
 find_package(nlohmann_json CONFIG REQUIRED)
@@ -578,6 +550,7 @@ find_package(zstd CONFIG REQUIRED)
 find_package(LibMagic MODULE REQUIRED)
 target_link_libraries(TILEDB_CORE_OBJECTS_ILIB
   INTERFACE
+    Blosc2::blosc2
     BZip2::BZip2
     lz4::lz4
     $<BUILD_INTERFACE:nlohmann_json::nlohmann_json>
diff --git a/tiledb/sm/filter/bitshuffle_filter.cc b/tiledb/sm/filter/bitshuffle_filter.cc
index 3e49bd9..7362872 100644
--- a/tiledb/sm/filter/bitshuffle_filter.cc
+++ b/tiledb/sm/filter/bitshuffle_filter.cc
@@ -37,7 +37,7 @@
 #include "tiledb/sm/enums/filter_type.h"
 #include "tiledb/sm/tile/tile.h"
 
-#include "bitshuffle_core.h"
+#include <blosc2.h>
 
 using namespace tiledb::common;
 
@@ -124,37 +124,23 @@ Status BitshuffleFilter::compute_parts(
 Status BitshuffleFilter::shuffle_part(
     const WriterTile&, const ConstBuffer* part, Buffer* output) const {
   auto tile_type_size = static_cast<uint8_t>(datatype_size(filter_data_type_));
-  auto part_nelts = part->size() / tile_type_size;
-  auto bytes_processed = bshuf_bitshuffle(
-      part->data(), output->cur_data(), part_nelts, tile_type_size, 0);
-
-  switch (bytes_processed) {
-    case -1:
-      return LOG_STATUS(
-          Status_FilterError("Bitshuffle error; Failed to allocate memory."));
-    case -11:
-      return LOG_STATUS(Status_FilterError("Bitshuffle error; Missing SSE."));
-    case -12:
-      return LOG_STATUS(Status_FilterError("Bitshuffle error; Missing AVX."));
-    case -80:
-      return LOG_STATUS(Status_FilterError(
-          "Bitshuffle error; Input size not a multiple of 8."));
-    case -81:
-      return LOG_STATUS(Status_FilterError(
-          "Bitshuffle error; Block size not a multiple of 8."));
-    case -91:
-      return LOG_STATUS(
-          Status_FilterError("Bitshuffle error; Decompression error, wrong "
-                             "number of bytes processed."));
-    default: {
-      if (bytes_processed != (int64_t)part->size())
-        return LOG_STATUS(Status_FilterError(
-            "Bitshuffle error; Unhandled internal error code " +
-            std::to_string(bytes_processed)));
-      break;
-    }
+  auto bytes_processed = blosc2_bitshuffle(
+      tile_type_size,
+      part->size(),
+      (uint8_t*)part->data(),
+      (uint8_t*)output->cur_data());
+
+  if (bytes_processed < 0) {
+    return LOG_STATUS(Status_FilterError(
+        std::string("Bitshuffle error; ") +
+        blosc2_error_string(bytes_processed)));
   }
 
+  if (bytes_processed != (int64_t)part->size())
+    return LOG_STATUS(Status_FilterError(
+        "Bitshuffle error; Unhandled internal error code " +
+        std::to_string(bytes_processed)));
+
   return Status::Ok();
 }
 
@@ -207,37 +193,23 @@ Status BitshuffleFilter::run_reverse(
 Status BitshuffleFilter::unshuffle_part(
     const Tile&, const ConstBuffer* part, Buffer* output) const {
   auto tile_type_size = static_cast<uint8_t>(datatype_size(filter_data_type_));
-  auto part_nelts = part->size() / tile_type_size;
-  auto bytes_processed = bshuf_bitunshuffle(
-      part->data(), output->cur_data(), part_nelts, tile_type_size, 0);
-
-  switch (bytes_processed) {
-    case -1:
-      return LOG_STATUS(
-          Status_FilterError("Bitshuffle error; Failed to allocate memory."));
-    case -11:
-      return LOG_STATUS(Status_FilterError("Bitshuffle error; Missing SSE."));
-    case -12:
-      return LOG_STATUS(Status_FilterError("Bitshuffle error; Missing AVX."));
-    case -80:
-      return LOG_STATUS(Status_FilterError(
-          "Bitshuffle error; Input size not a multiple of 8."));
-    case -81:
-      return LOG_STATUS(Status_FilterError(
-          "Bitshuffle error; Block size not a multiple of 8."));
-    case -91:
-      return LOG_STATUS(
-          Status_FilterError("Bitshuffle error; Decompression error, wrong "
-                             "number of bytes processed."));
-    default: {
-      if (bytes_processed != (int64_t)part->size())
-        return LOG_STATUS(Status_FilterError(
-            "Bitshuffle error; Unhandled internal error code " +
-            std::to_string(bytes_processed)));
-      break;
-    }
+  auto bytes_processed = blosc2_bitunshuffle(
+      tile_type_size,
+      part->size(),
+      (uint8_t*)part->data(),
+      (uint8_t*)output->cur_data());
+
+  if (bytes_processed < 0) {
+    return LOG_STATUS(Status_FilterError(
+        std::string("Bitunshuffle error; ") +
+        blosc2_error_string(bytes_processed)));
   }
 
+  if (bytes_processed != (int64_t)part->size())
+    return LOG_STATUS(Status_FilterError(
+        "Bitshuffle error; Unhandled internal error code " +
+        std::to_string(bytes_processed)));
+
   return Status::Ok();
 }
 
diff --git a/tiledb/sm/filter/byteshuffle_filter.cc b/tiledb/sm/filter/byteshuffle_filter.cc
index b142cd7..c11efe7 100644
--- a/tiledb/sm/filter/byteshuffle_filter.cc
+++ b/tiledb/sm/filter/byteshuffle_filter.cc
@@ -37,7 +37,7 @@
 #include "tiledb/sm/enums/filter_type.h"
 #include "tiledb/sm/tile/tile.h"
 
-#include "blosc/tiledb-shuffle.h"
+#include <blosc2.h>
 
 using namespace tiledb::common;
 
@@ -94,12 +94,17 @@ Status ByteshuffleFilter::shuffle_part(
     const WriterTile&, const ConstBuffer* part, Buffer* output) const {
   auto tile_type_size = static_cast<uint8_t>(datatype_size(filter_data_type_));
 
-  blosc::shuffle(
+  int status = blosc2_shuffle(
       tile_type_size,
       part->size(),
       (uint8_t*)part->data(),
       (uint8_t*)output->cur_data());
 
+  if (status < 0) {
+    return Status_FilterError(
+        std::string("Shuffle error; ") + blosc2_error_string(status));
+  }
+
   return Status::Ok();
 }
 
@@ -146,12 +151,17 @@ Status ByteshuffleFilter::unshuffle_part(
     const Tile&, const ConstBuffer* part, Buffer* output) const {
   auto tile_type_size = static_cast<uint8_t>(datatype_size(filter_data_type_));
 
-  blosc::unshuffle(
+  int status = blosc2_unshuffle(
       tile_type_size,
       part->size(),
       (uint8_t*)part->data(),
       (uint8_t*)output->cur_data());
 
+  if (status < 0) {
+    return Status_FilterError(
+        std::string("Unshuffle error; ") + blosc2_error_string(status));
+  }
+
   return Status::Ok();
 }
 
diff --git a/tiledb/sm/filter/CMakeLists.txt b/tiledb/sm/filter/CMakeLists.txt
index 54b4ebe..1489012 100644
--- a/tiledb/sm/filter/CMakeLists.txt
+++ b/tiledb/sm/filter/CMakeLists.txt
@@ -27,6 +27,8 @@
 include(common NO_POLICY_SCOPE)
 include(object_library)
 
+find_package(Blosc2 CONFIG REQUIRED)
+
 #
 # `filter` object library
 #
@@ -39,44 +41,18 @@ conclude(object_library)
 # `bitshuffle_filter` object library
 #
 commence(object_library bitshuffle_filter)
-    # Dependency on external/bitshuffle is direct, not by add_subdirectory
-    cmake_path(APPEND TILEDB_SOURCE_ROOT "external/src/bitshuffle" OUTPUT_VARIABLE BITSHUFFLE_SOURCE_ROOT)
-    cmake_path(APPEND TILEDB_SOURCE_ROOT "external/include/bitshuffle" OUTPUT_VARIABLE BITSHUFFLE_INCLUDE)
-    list(APPEND BITSHUFFLE_SOURCES
-        ${BITSHUFFLE_SOURCE_ROOT}/bitshuffle_core.cc
-        ${BITSHUFFLE_SOURCE_ROOT}/iochain.cc
-        )
-    this_target_sources(bitshuffle_filter.cc ${BITSHUFFLE_SOURCES})
+    this_target_sources(bitshuffle_filter.cc)
     this_target_object_libraries(baseline buffer filter)
-    set_source_files_properties(
-        bitshuffle_filter.cc ${BITSHUFFLE_SOURCES}
-        PROPERTIES
-        INCLUDE_DIRECTORIES "${BITSHUFFLE_INCLUDE}"
-    )
+    this_target_link_libraries(Blosc2::blosc2)
 conclude(object_library)
 
 #
 # `byteshuffle_filter` object library
 #
-# `byteshuffle_filter` depends on blosc, so we need to add its subdirectory. At
-# the present time, that subdirectory is also being added in the main build.
-# Adding the same directory twice causes an error. Thus, in the interim, we use
-# `blosc-alt` for the binary. This also means that we're compiling blosc
-# separately for the main build and for the unit. These separation is temporary
-# for the duration of converting the main build into a unit-dependent one.
-#
 commence(object_library byteshuffle_filter)
-    # Dependency on external/blosc
-    cmake_path(APPEND TILEDB_SOURCE_ROOT "external/blosc" OUTPUT_VARIABLE BLOSC_SOURCE_ROOT)
-    cmake_path(APPEND CMAKE_BINARY_DIR "external/blosc-alt" OUTPUT_VARIABLE BLOSC_BINARY_ROOT)
-    add_subdirectory(${BLOSC_SOURCE_ROOT} ${BLOSC_BINARY_ROOT})
-    this_target_sources(byteshuffle_filter.cc ${TileDB_blosc_SOURCES})
+    this_target_sources(byteshuffle_filter.cc)
     this_target_object_libraries(baseline buffer filter)
-    # [As of CMake 3.21] Setting private options on object libraries does not set
-    # the corresponding properties on sources in the object library.
-    set_source_files_properties(byteshuffle_filter.cc PROPERTIES INCLUDE_DIRECTORIES "${TILEDB_EXTERNAL_INCLUDE};${TileDB_blosc_INCLUDE_DIRS}")
-    set_source_files_properties(${TileDB_blosc_SOURCES} PROPERTIES INCLUDE_DIRECTORIES "${TileDB_blosc_INCLUDE_DIRS}")
-    set_source_files_properties(${TileDB_blosc_SOURCES} PROPERTIES COMPILE_OPTIONS "${TileDB_blosc_COMPILE_OPTIONS}")
+    this_target_link_libraries(Blosc2::blosc2)
 conclude(object_library)
 
 #
