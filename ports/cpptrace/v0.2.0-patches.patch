diff --git a/CMakeLists.txt b/CMakeLists.txt
index ea088e9..e142713 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -97,23 +97,13 @@ if(NOT CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
   check_support(HAS_CXXABI has_cxxabi.cpp "" "" "")
 endif()

-if(NOT WIN32) # No need to bother checking in msvc, but do check in minngw
+if(NOT WIN32)
   check_support(HAS_UNWIND has_unwind.cpp "" "" "")
   check_support(HAS_EXECINFO has_execinfo.cpp "" "" "")
   check_support(HAS_BACKTRACE has_backtrace.cpp "" "backtrace" "${CPPTRACE_BACKTRACE_PATH_DEFINITION}")
-  check_support(HAS_DL has_dl.cpp "" "dl" "")
   set(STACKTRACE_LINK_LIB "stdc++_libbacktrace")
-  check_support(HAS_STACKTRACE has_stacktrace.cpp "" "${STACKTRACE_LINK_LIB}" "")
-  if(APPLE)
-    find_program(ADDR2LINE_PATH atos PATHS ENV PATH)
-  else()
-    find_program(ADDR2LINE_PATH addr2line PATHS ENV PATH)
-  endif()
-  if("${ADDR2LINE_PATH}" STREQUAL "ADDR2LINE_PATH-NOTFOUND")
-    set(HAS_ADDR2LINE FALSE)
-  else()
-    set(HAS_ADDR2LINE TRUE)
-  endif()
+else()
+  check_support(HAS_STACKWALK has_stackwalk.cpp "" "dbghelp" "")
 endif()

 # =============================================== Autoconfig unwinding ===============================================
@@ -139,12 +129,14 @@ if(
       set(CPPTRACE_UNWIND_WITH_NOTHING On)
       message(FATAL_ERROR "Cpptrace auto config: No unwinding back-end seems to be supported, stack tracing will not work. To compile anyway set CPPTRACE_UNWIND_WITH_NOTHING.")
     endif()
-  elseif(MINGW)
-    set(CPPTRACE_UNWIND_WITH_DBGHELP On)
-    message(STATUS "Cpptrace auto config: Using dbghelp for unwinding")
-  elseif(WIN32)
-    set(CPPTRACE_UNWIND_WITH_DBGHELP On)
-    message(STATUS "Cpptrace auto config: Using dbghelp for unwinding")
+  elseif(MINGW OR WIN32)
+    if(HAS_STACKWALK)
+      set(CPPTRACE_UNWIND_WITH_DBGHELP On)
+      message(STATUS "Cpptrace auto config: Using dbghelp for unwinding")
+    else()
+      set(CPPTRACE_UNWIND_WITH_WINAPI On)
+      message(STATUS "Cpptrace auto config: Using winapi for unwinding")
+    endif()
   endif()
 else()
   #message(STATUS "MANUAL CONFIG SPECIFIED")
@@ -202,8 +194,6 @@ endif()

 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)

-set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-
 set(
   sources
   src/cpptrace.cpp
@@ -228,6 +218,7 @@ if(CPPTRACE_STATIC)
   add_library(cpptrace STATIC ${sources} include/cpptrace/cpptrace.hpp)
 else()
   add_library(cpptrace SHARED ${sources} include/cpptrace/cpptrace.hpp)
+  set_property(TARGET cpptrace PROPERTY POSITION_INDEPENDENT_CODE ON)
 endif()

 target_include_directories(
@@ -250,9 +241,8 @@ set_target_properties(
 target_compile_options(
   cpptrace
   PRIVATE
-  #  -Wshadow
   $<$<NOT:$<CXX_COMPILER_ID:MSVC>>:-Wall -Wextra -Werror=return-type -Wundef>
-  $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast -Wnonnull-compare>
+  $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast>
   $<$<CXX_COMPILER_ID:MSVC>:/W4 /WX /permissive->
 )

@@ -347,6 +337,9 @@ if(CPPTRACE_UNWIND_WITH_WINAPI)
 endif()

 if(CPPTRACE_UNWIND_WITH_DBGHELP)
+  if(NOT HAS_STACKWALK)
+    message(WARNING "Cpptrace: CPPTRACE_UNWIND_WITH_DBGHELP specified but dbghelp stackwalk64 doesn't seem to be available.")
+  endif()
   target_compile_definitions(cpptrace PUBLIC CPPTRACE_UNWIND_WITH_DBGHELP)
   target_link_libraries(cpptrace PRIVATE dbghelp)
 endif()
@@ -385,9 +378,15 @@ endif()
 if(NOT CMAKE_SKIP_INSTALL_RULES)
   include(CMakePackageConfigHelpers)

+  if(CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF)
+    set(CPPTRACE_STATIC_EXPORT_TARGETS cpptrace dwarf)
+  else()
+    set(CPPTRACE_STATIC_EXPORT_TARGETS cpptrace)
+  endif()
+
   if(CPPTRACE_STATIC)
     install(
-      TARGETS cpptrace dwarf
+      TARGETS ${CPPTRACE_STATIC_EXPORT_TARGETS}
       EXPORT cpptrace_targets
       LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
       INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
diff --git a/README.md b/README.md
index 2642c9f..38f02c1 100644
--- a/README.md
+++ b/README.md
@@ -2,13 +2,11 @@

 [![build](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/build.yml/badge.svg?branch=main)](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/build.yml)
 [![test](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/test.yml/badge.svg?branch=main)](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/test.yml)
-[![performance-test](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/performance-tests.yml/badge.svg?branch=main)](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/performance-tests.yml)
-[![cmake-integration](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/cmake-integration.yml/badge.svg?branch=main)](https://github.com/jeremy-rifkin/cpptrace/actions/workflows/cmake-integration.yml)
 <br/>
 [![Community Discord Link](https://img.shields.io/badge/Chat%20on%20(the%20very%20small)-Community%20Discord-blue?labelColor=2C3239&color=7289DA&style=flat&logo=discord&logoColor=959DA5)](https://discord.gg/7kv5AuCndG)

-Cpptrace is a lightweight C++ stacktrace library supporting C++11 and greater on Linux, macOS, and Windows including
-MinGW and Cygwin environments. The goal: Make stack traces simple for once.
+Cpptrace is a simple, portable, and self-contained C++ stacktrace library supporting C++11 and greater on Linux, macOS,
+and Windows including MinGW and Cygwin environments. The goal: Make stack traces simple for once.

 ## Table of Contents <!-- omit in toc -->

diff --git a/bundled/libdwarf/CMakeLists.txt b/bundled/libdwarf/CMakeLists.txt
index bc30c88..148e5df 100644
--- a/bundled/libdwarf/CMakeLists.txt
+++ b/bundled/libdwarf/CMakeLists.txt
@@ -217,74 +217,85 @@ check_c_source_compiles([=[
   }]=] HAVE_STDAFX_H)
 #message(STATUS "Checking have windows stdafx.h... ${HAVE_STDAFX_H}")

-set(CMAKE_REQUIRED_LIBRARIES z)
-check_c_source_compiles( [=[
-  #include "zlib.h"
-  int main()
-  {
-      Bytef dest[100];
-      uLongf destlen = 100;
-      Bytef *src = 0;
-      uLong srclen = 3;
-      int res = uncompress(dest,&destlen,src,srclen);
-      if (res == Z_OK) {
-           /* ALL IS WELL */
-      }
-      return 0;
-  } ]=]  HAVE_ZLIB )
-check_c_source_compiles( [=[
-  #include "zlib.h"
-  int main()
-  {
-      Bytef dest[100];
-      uLongf destlen = 100;
-      Bytef *src = 0;
-      uLong srclen = 3;
-      int res = uncompress(dest,&destlen,src,srclen);
-      if (res == Z_OK) {
-           /* ALL IS WELL */
-      }
-      return 0;
-  } ]=]  HAVE_ZLIB_H )
-set(CMAKE_REQUIRED_LIBRARIES)
-if (HAVE_ZLIB)
-  # For linking in libz
-  set(DW_FZLIB "z")
-endif()
+option(CMAKE_DWARF_FINDPACKAGE_Z "" OFF)
+
+mark_as_advanced(CMAKE_DWARF_FINDPACKAGE_Z)
+
+if(NOT CMAKE_DWARF_FINDPACKAGE_Z)
+  set(CMAKE_REQUIRED_LIBRARIES z)
+  check_c_source_compiles( [=[
+    #include "zlib.h"
+    int main()
+    {
+        Bytef dest[100];
+        uLongf destlen = 100;
+        Bytef *src = 0;
+        uLong srclen = 3;
+        int res = uncompress(dest,&destlen,src,srclen);
+        if (res == Z_OK) {
+            /* ALL IS WELL */
+        }
+        return 0;
+    } ]=]  HAVE_ZLIB )
+  check_c_source_compiles( [=[
+    #include "zlib.h"
+    int main()
+    {
+        Bytef dest[100];
+        uLongf destlen = 100;
+        Bytef *src = 0;
+        uLong srclen = 3;
+        int res = uncompress(dest,&destlen,src,srclen);
+        if (res == Z_OK) {
+            /* ALL IS WELL */
+        }
+        return 0;
+    } ]=]  HAVE_ZLIB_H )
+  set(CMAKE_REQUIRED_LIBRARIES)
+  if (HAVE_ZLIB)
+    # For linking in libz
+    set(DW_FZLIB "z")
+  endif()

-set(CMAKE_REQUIRED_LIBRARIES zstd )
-check_c_source_compiles( [=[
-  #include "zstd.h"
-  int main()
-  {
-      char * dest[100];
-      size_t destlen = 100;
-      char *src = 0;
-      size_t srclen = 3;
-      size_t res = ZSTD_decompress(dest,destlen,src,srclen);
-      if (res == destlen) {
-           /* ALL IS WELL */
-      }
-      return 0;
-  } ]=]  HAVE_ZSTD )
-check_c_source_compiles( [=[
-  #include "zstd.h"
-  int main()
-  {
-      char * dest[100];
-      size_t destlen = 100;
-      char *src = 0;
-      size_t srclen = 3;
-      size_t res = ZSTD_decompress(dest,destlen,src,srclen);
-      if (res == destlen) {
-           /* ALL IS WELL */
-      }
-      return 0;
-  } ]=]  HAVE_ZSTD_H )
-set(CMAKE_REQUIRED_LIBRARIES)
-if (HAVE_ZSTD)
-  # For linking in libzstd
-  set(DW_FZSTD "zstd")
+  set(CMAKE_REQUIRED_LIBRARIES zstd )
+  check_c_source_compiles( [=[
+    #include "zstd.h"
+    int main()
+    {
+        char * dest[100];
+        size_t destlen = 100;
+        char *src = 0;
+        size_t srclen = 3;
+        size_t res = ZSTD_decompress(dest,destlen,src,srclen);
+        if (res == destlen) {
+            /* ALL IS WELL */
+        }
+        return 0;
+    } ]=]  HAVE_ZSTD )
+  check_c_source_compiles( [=[
+    #include "zstd.h"
+    int main()
+    {
+        char * dest[100];
+        size_t destlen = 100;
+        char *src = 0;
+        size_t srclen = 3;
+        size_t res = ZSTD_decompress(dest,destlen,src,srclen);
+        if (res == destlen) {
+            /* ALL IS WELL */
+        }
+        return 0;
+    } ]=]  HAVE_ZSTD_H )
+  set(CMAKE_REQUIRED_LIBRARIES)
+  if (HAVE_ZSTD)
+    # For linking in libzstd
+    set(DW_FZSTD "zstd")
+  endif()
+else()
+  find_package(ZLIB REQUIRED)
+  set(DW_FZLIB "ZLIB")
+  set(HAVE_ZLIB TRUE)
+  set(HAVE_ZLIB_H TRUE)
 endif()

 check_c_source_compiles([=[
@@ -421,12 +432,10 @@ set(

 set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)

-### libassert uses relocs, -fpic has to be used to allow shared libs to link libassert as a static library.
-##set(CMAKE_POSITION_INDEPENDENT_CODE ON)
-
 include(GNUInstallDirs)

-add_library(dwarf STATIC ${libdwarf_sources} ${libdwarf_headers})
+add_library(dwarf OBJECT ${libdwarf_sources} ${libdwarf_headers})
+set_property(TARGET dwarf PROPERTY POSITION_INDEPENDENT_CODE ON)

 target_compile_definitions(dwarf PUBLIC LIBDWARF_BUILD)

@@ -436,7 +445,11 @@ target_include_directories(
   $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
 )

-target_link_libraries(dwarf PUBLIC ${LIBELF_LIBRARIES} ${DW_FZLIB} ${DW_FZSTD})
+if(CMAKE_DWARF_FINDPACKAGE_Z)
+  target_link_libraries(dwarf PUBLIC ZLIB::ZLIB)
+else()
+  target_link_libraries(dwarf PUBLIC ${DW_FZLIB} ${DW_FZSTD})
+endif()

 # TODO: Something will have to be figured out for dynamic linking, but for now there's nothing to install
 # if(NOT CMAKE_SKIP_INSTALL_RULES)
diff --git a/cmake/has_stacktrace.cpp b/cmake/has_stacktrace.cpp
deleted file mode 100644
index df60219..0000000
--- a/cmake/has_stacktrace.cpp
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <stacktrace>
-
-int main() {
-    std::stacktrace trace = std::stacktrace::current();
-    for(const auto entry : trace) {
-        (void)entry;
-    }
-}
diff --git a/cmake/has_stackwalk.cpp b/cmake/has_stackwalk.cpp
new file mode 100644
index 0000000..eff05b9
--- /dev/null
+++ b/cmake/has_stackwalk.cpp
@@ -0,0 +1,101 @@
+#include <windows.h>
+#include <dbghelp.h>
+
+#define IS_CLANG 0
+#define IS_GCC 0
+#define IS_MSVC 0
+
+#if defined(__clang__)
+ #undef IS_CLANG
+ #define IS_CLANG 1
+#elif defined(__GNUC__) || defined(__GNUG__)
+ #undef IS_GCC
+ #define IS_GCC 1
+#elif defined(_MSC_VER)
+ #undef IS_MSVC
+ #define IS_MSVC 1
+#else
+ #error "Unsupported compiler"
+#endif
+
+int main() {
+    HANDLE proc = GetCurrentProcess();
+    HANDLE thread = GetCurrentThread();
+    // https://jpassing.com/2008/03/12/walking-the-stack-of-the-current-thread/
+
+    // Get current thread context
+    // GetThreadContext cannot be used on the current thread.
+    // RtlCaptureContext doesn't work on i386
+    CONTEXT context;
+    #if defined(_M_IX86) || defined(__i386__)
+    ZeroMemory(&context, sizeof(CONTEXT));
+    context.ContextFlags = CONTEXT_CONTROL;
+    #if IS_MSVC
+    __asm {
+        label:
+        mov [context.Ebp], ebp;
+        mov [context.Esp], esp;
+        mov eax, [label];
+        mov [context.Eip], eax;
+    }
+    #else
+    asm(
+        "label:\n\t"
+        "mov{l %%ebp, %[cEbp] | %[cEbp], ebp};\n\t"
+        "mov{l %%esp, %[cEsp] | %[cEsp], esp};\n\t"
+        "mov{l $label, %%eax | eax, label};\n\t"
+        "mov{l %%eax, %[cEip] | %[cEip], eax};\n\t"
+        : [cEbp] "=r" (context.Ebp),
+            [cEsp] "=r" (context.Esp),
+            [cEip] "=r" (context.Eip)
+    );
+    #endif
+    #else
+    RtlCaptureContext(&context);
+    #endif
+    // Setup current frame
+    STACKFRAME64 frame;
+    ZeroMemory(&frame, sizeof(STACKFRAME64));
+    DWORD machine_type;
+    #if defined(_M_IX86) || defined(__i386__)
+    machine_type           = IMAGE_FILE_MACHINE_I386;
+    frame.AddrPC.Offset    = context.Eip;
+    frame.AddrPC.Mode      = AddrModeFlat;
+    frame.AddrFrame.Offset = context.Ebp;
+    frame.AddrFrame.Mode   = AddrModeFlat;
+    frame.AddrStack.Offset = context.Esp;
+    frame.AddrStack.Mode   = AddrModeFlat;
+    #elif defined(_M_X64) || defined(__x86_64__)
+    machine_type           = IMAGE_FILE_MACHINE_AMD64;
+    frame.AddrPC.Offset    = context.Rip;
+    frame.AddrPC.Mode      = AddrModeFlat;
+    frame.AddrFrame.Offset = context.Rsp;
+    frame.AddrFrame.Mode   = AddrModeFlat;
+    frame.AddrStack.Offset = context.Rsp;
+    frame.AddrStack.Mode   = AddrModeFlat;
+    #elif defined(_M_IA64) || defined(__aarch64__)
+    machine_type           = IMAGE_FILE_MACHINE_IA64;
+    frame.AddrPC.Offset    = context.StIIP;
+    frame.AddrPC.Mode      = AddrModeFlat;
+    frame.AddrFrame.Offset = context.IntSp;
+    frame.AddrFrame.Mode   = AddrModeFlat;
+    frame.AddrBStore.Offset= context.RsBSP;
+    frame.AddrBStore.Mode  = AddrModeFlat;
+    frame.AddrStack.Offset = context.IntSp;
+    frame.AddrStack.Mode   = AddrModeFlat;
+    #else
+    #error "Cpptrace: StackWalk64 not supported for this platform yet"
+    #endif
+    ZeroMemory(&context, sizeof(CONTEXT));
+    StackWalk64(
+        machine_type,
+        proc,
+        thread,
+        &frame,
+        machine_type == IMAGE_FILE_MACHINE_I386 ? NULL : &context,
+        NULL,
+        SymFunctionTableAccess64,
+        SymGetModuleBase64,
+        NULL
+    );
+}
diff --git a/src/symbols/symbols_with_libdwarf.cpp b/src/symbols/symbols_with_libdwarf.cpp
index ea52632..314a402 100644
--- a/src/symbols/symbols_with_libdwarf.cpp
+++ b/src/symbols/symbols_with_libdwarf.cpp
@@ -458,7 +458,8 @@ namespace libdwarf {
                     &table_count,
                     &line_context
                 );
-                VERIFY(table_count >= 0 && table_count <= 2, "Unknown dwarf line table count");
+                static_assert(std::is_unsigned<decltype(table_count)>::value, "Expected unsigned Dwarf_Small");
+                VERIFY(/*table_count >= 0 &&*/ table_count <= 2, "Unknown dwarf line table count");
                 if(ret == DW_DLV_NO_ENTRY) {
                     // TODO: Failing silently for now
                     return;
@@ -674,7 +675,8 @@ namespace libdwarf {
                     }
                 }
                 if(resolver_object.has_value() && get_cache_mode() == cache_mode::prioritize_speed) {
-                    resolver_map.insert({obj_name, std::move(resolver_object).unwrap()});
+                    // .emplace needed, for some reason .insert tries to copy <= gcc 7.2
+                    resolver_map.emplace(obj_name, std::move(resolver_object).unwrap());
                 }
             } catch(...) {
                 if(!should_absorb_trace_exceptions()) {
diff --git a/src/unwind/unwind_with_dbghelp.cpp b/src/unwind/unwind_with_dbghelp.cpp
index c6f035a..f1005af 100644
--- a/src/unwind/unwind_with_dbghelp.cpp
+++ b/src/unwind/unwind_with_dbghelp.cpp
@@ -21,6 +21,10 @@

 namespace cpptrace {
 namespace detail {
+    #if IS_MSVC
+    #pragma warning(push)
+    #pragma warning(disable: 4740) // warning C4740: flow in or out of inline asm code suppresses global optimization
+    #endif
     CPPTRACE_FORCE_NO_INLINE
     std::vector<uintptr_t> capture_frames(size_t skip, size_t max_depth) {
         skip++;
@@ -30,9 +34,10 @@ namespace detail {
         // GetThreadContext cannot be used on the current thread.
         // RtlCaptureContext doesn't work on i386
         CONTEXT context;
-        #ifdef _M_IX86
+        #if defined(_M_IX86) || defined(__i386__)
         ZeroMemory(&context, sizeof(CONTEXT));
         context.ContextFlags = CONTEXT_CONTROL;
+        #if IS_MSVC
         __asm {
             label:
             mov [context.Ebp], ebp;
@@ -41,13 +46,25 @@ namespace detail {
             mov [context.Eip], eax;
         }
         #else
+        asm(
+            "label:\n\t"
+            "mov{l %%ebp, %[cEbp] | %[cEbp], ebp};\n\t"
+            "mov{l %%esp, %[cEsp] | %[cEsp], esp};\n\t"
+            "mov{l $label, %%eax | eax, OFFSET label};\n\t"
+            "mov{l %%eax, %[cEip] | %[cEip], eax};\n\t"
+            : [cEbp] "=r" (context.Ebp),
+              [cEsp] "=r" (context.Esp),
+              [cEip] "=r" (context.Eip)
+        );
+        #endif
+        #else
         RtlCaptureContext(&context);
         #endif
         // Setup current frame
         STACKFRAME64 frame;
         ZeroMemory(&frame, sizeof(STACKFRAME64));
         DWORD machine_type;
-        #ifdef _M_IX86
+        #if defined(_M_IX86) || defined(__i386__)
         machine_type           = IMAGE_FILE_MACHINE_I386;
         frame.AddrPC.Offset    = context.Eip;
         frame.AddrPC.Mode      = AddrModeFlat;
@@ -55,7 +72,7 @@ namespace detail {
         frame.AddrFrame.Mode   = AddrModeFlat;
         frame.AddrStack.Offset = context.Esp;
         frame.AddrStack.Mode   = AddrModeFlat;
-        #elif _M_X64
+        #elif defined(_M_X64) || defined(__x86_64__)
         machine_type           = IMAGE_FILE_MACHINE_AMD64;
         frame.AddrPC.Offset    = context.Rip;
         frame.AddrPC.Mode      = AddrModeFlat;
@@ -63,7 +80,7 @@ namespace detail {
         frame.AddrFrame.Mode   = AddrModeFlat;
         frame.AddrStack.Offset = context.Rsp;
         frame.AddrStack.Mode   = AddrModeFlat;
-        #elif _M_IA64
+        #elif defined(_M_IA64) || defined(__aarch64__)
         machine_type           = IMAGE_FILE_MACHINE_IA64;
         frame.AddrPC.Offset    = context.StIIP;
         frame.AddrPC.Mode      = AddrModeFlat;
@@ -121,7 +138,7 @@ namespace detail {
                     // On x86/x64/arm, as far as I can tell, the frame return address is always one after the call
                     // So we just decrement to get the pc back inside the `call` / `bl`
                     // This is done with _Unwind too but conditionally based on info from _Unwind_GetIPInfo.
-                    trace.push_back(frame.AddrPC.Offset - 1);
+                    trace.push_back(static_cast<uintptr_t>(frame.AddrPC.Offset) - 1);
                 }
             } else {
                 // base
@@ -135,6 +152,9 @@ namespace detail {
         }
         return trace;
     }
+    #if IS_MSVC
+    #pragma warning(pop)
+    #endif
 }
 }

