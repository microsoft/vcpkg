# Internal helper for editable mode in vcpkg_from_git/github/gitlab/bitbucket
# This function handles cloning and patching for editable ports.
# Supports multiple source downloads via numbered subdirectories (${PORT}-src1, ${PORT}-src2, etc.)
#
# Prerequisites (caller must check before calling):
#   _VCPKG_EDITABLE must be TRUE
#   _VCPKG_EDITABLE_SOURCES_PATH must be defined
#   PORT must be defined (standard vcpkg variable)
#
# Arguments:
#   URL               - Git URL to clone from
#   REF               - Git ref (commit/tag/branch) to checkout
#   OUT_SOURCE_PATH   - Variable name to set with the source path
#   PATCHES           - List of patches to apply
#   FETCH_REF         - (Optional) Ref to fetch if REF is not directly fetchable
#   HEAD_REF          - (Optional) Branch name for HEAD version builds
#   LFS               - (Optional) URL for LFS fetch (empty string = use URL)
#   AUTHORIZATION_TOKEN - (Optional) Auth token for private repos
#
# Sets in PARENT_SCOPE:
#   ${OUT_SOURCE_PATH} - Path to the editable source (e.g., sources/zlib-src1)
#   VCPKG_HEAD_VERSION - (When HEAD_REF used) The resolved commit SHA
#
# Uses CACHE variables:
#   _VCPKG_EDITABLE_SOURCE_COUNT_${PORT} - Per-port counter for multiple source downloads
#
# Metadata tracking:
#   Stores call parameters in sources/${PORT}-srcN.meta.json to detect configuration drift.
#   Includes resolved git SHA and timestamp.
#   On subsequent calls, warns if parameters have changed from initial clone.
#   Initial clone failures are atomic - source folder and metadata are cleaned up.

include("${CMAKE_CURRENT_LIST_DIR}/z_vcpkg_apply_patches.cmake")
include(vcpkg_execute_in_download_mode)

# Helper: Normalize patches list to relative paths for consistent comparison
function(z_vcpkg_editable_normalize_patches out_var patches_list)
    set(_normalized_patches "")
    foreach(_patch IN LISTS patches_list)
        # Get just the filename for comparison (patches are relative to CURRENT_PORT_DIR)
        get_filename_component(_patch_name "${_patch}" NAME)
        list(APPEND _normalized_patches "${_patch_name}")
    endforeach()
    # Keep original order - do not sort
    set("${out_var}" "${_normalized_patches}" PARENT_SCOPE)
endfunction()

# Helper: Get metadata file path for a given source name
function(z_vcpkg_editable_get_meta_path out_var sources_base_path source_name)
    set("${out_var}" "${sources_base_path}/${source_name}.git-metadata.json" PARENT_SCOPE)
endfunction()

# Helper: Write metadata file with current call parameters (JSON format)
function(z_vcpkg_editable_write_metadata meta_file_path url ref patches_list resolved_sha fetch_ref lfs)
    z_vcpkg_editable_normalize_patches(_normalized_patches "${patches_list}")
    
    # Get current timestamp
    string(TIMESTAMP _created_at "%Y-%m-%dT%H:%M:%SZ" UTC)
    
    # Build JSON object using string(JSON)
    set(_json "{}")
    string(JSON _json SET "${_json}" "$comment" "\"Auto-generated by z_vcpkg_from_git_editable - DO NOT EDIT\"")
    string(JSON _json SET "${_json}" "url" "\"${url}\"")
    string(JSON _json SET "${_json}" "ref" "\"${ref}\"")
    string(JSON _json SET "${_json}" "resolved_sha" "\"${resolved_sha}\"")
    string(JSON _json SET "${_json}" "fetch_ref" "\"${fetch_ref}\"")
    string(JSON _json SET "${_json}" "lfs" "\"${lfs}\"")
    
    # Build patches array (append to maintain order)
    set(_patches_array "[]")
    set(_patch_idx 0)
    foreach(_patch IN LISTS _normalized_patches)
        string(JSON _patches_array SET "${_patches_array}" ${_patch_idx} "\"${_patch}\"")
        math(EXPR _patch_idx "${_patch_idx} + 1")
    endforeach()
    string(JSON _json SET "${_json}" "patches" "${_patches_array}")
    
    string(JSON _json SET "${_json}" "created_at" "\"${_created_at}\"")
    
    # Write JSON file
    file(WRITE "${meta_file_path}" "${_json}\n")
endfunction()

# Helper: Check if current call parameters match stored metadata
# Returns: TRUE if matches, FALSE if mismatch or no metadata
function(z_vcpkg_editable_check_metadata out_matches out_message meta_file_path url ref patches_list fetch_ref lfs)
    # No metadata file - this is an error (source exists but metadata doesn't)
    if(NOT EXISTS "${meta_file_path}")
        set("${out_matches}" FALSE PARENT_SCOPE)
        set("${out_message}" "\n  Metadata file missing: ${meta_file_path}" PARENT_SCOPE)
        return()
    endif()
    
    # Read and parse JSON metadata
    file(READ "${meta_file_path}" _meta_json)
    
    string(JSON _stored_url ERROR_VARIABLE _url_error GET "${_meta_json}" "url")
    string(JSON _stored_ref ERROR_VARIABLE _ref_error GET "${_meta_json}" "ref")
    string(JSON _stored_fetch_ref ERROR_VARIABLE _fetch_ref_error GET "${_meta_json}" "fetch_ref")
    string(JSON _stored_lfs ERROR_VARIABLE _lfs_error GET "${_meta_json}" "lfs")
    
    if(_url_error OR _ref_error)
        set("${out_matches}" FALSE PARENT_SCOPE)
        set("${out_message}" "\n  Metadata file corrupt or invalid: ${meta_file_path}" PARENT_SCOPE)
        return()
    endif()
    
    # Handle missing fetch_ref/lfs in older metadata files (treat as empty)
    if(_fetch_ref_error)
        set(_stored_fetch_ref "")
    endif()
    if(_lfs_error)
        set(_stored_lfs "")
    endif()
    
    # Parse stored patches array
    set(_stored_patches "")
    string(JSON _patches_count ERROR_VARIABLE _count_error LENGTH "${_meta_json}" "patches")
    if(NOT _count_error AND _patches_count GREATER 0)
        math(EXPR _last_idx "${_patches_count} - 1")
        foreach(_idx RANGE 0 ${_last_idx})
            string(JSON _patch_name GET "${_meta_json}" "patches" ${_idx})
            list(APPEND _stored_patches "${_patch_name}")
        endforeach()
    endif()
    # Keep original order - do not sort
    
    # Normalize current patches for comparison (also preserves order)
    z_vcpkg_editable_normalize_patches(_current_patches "${patches_list}")
    
    # Build list of differences
    set(_differences "")
    
    if(NOT "${url}" STREQUAL "${_stored_url}")
        string(APPEND _differences "\n  URL: was '${_stored_url}', now '${url}'")
    endif()
    
    if(NOT "${ref}" STREQUAL "${_stored_ref}")
        string(APPEND _differences "\n  REF: was '${_stored_ref}', now '${ref}'")
    endif()
    
    if(NOT "${fetch_ref}" STREQUAL "${_stored_fetch_ref}")
        string(APPEND _differences "\n  FETCH_REF: was '${_stored_fetch_ref}', now '${fetch_ref}'")
    endif()
    
    if(NOT "${lfs}" STREQUAL "${_stored_lfs}")
        string(APPEND _differences "\n  LFS: was '${_stored_lfs}', now '${lfs}'")
    endif()
    
    # Compare patches lists - direct comparison (order matters)
    if(NOT "${_current_patches}" STREQUAL "${_stored_patches}")
        string(REPLACE ";" ", " _stored_str "${_stored_patches}")
        string(REPLACE ";" ", " _current_str "${_current_patches}")
        string(APPEND _differences "\n  PATCHES: was [${_stored_str}], now [${_current_str}]")
    endif()
    
    if("${_differences}" STREQUAL "")
        set("${out_matches}" TRUE PARENT_SCOPE)
        set("${out_message}" "" PARENT_SCOPE)
    else()
        set("${out_matches}" FALSE PARENT_SCOPE)
        set("${out_message}" "${_differences}" PARENT_SCOPE)
    endif()
endfunction()

# Helper: Cleanup source folder and metadata on initial clone failure
function(z_vcpkg_editable_cleanup_on_failure source_path meta_file_path)
    if(EXISTS "${source_path}")
        file(REMOVE_RECURSE "${source_path}")
    endif()
    if(EXISTS "${meta_file_path}")
        file(REMOVE "${meta_file_path}")
    endif()
endfunction()

function(z_vcpkg_from_git_editable)
    cmake_parse_arguments(PARSE_ARGV 0 arg
        ""
        "URL;REF;FETCH_REF;HEAD_REF;LFS;AUTHORIZATION_TOKEN;OUT_SOURCE_PATH"
        "PATCHES"
    )

    if(DEFINED arg_UNPARSED_ARGUMENTS)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: unexpected arguments: ${arg_UNPARSED_ARGUMENTS}")
    endif()

    # Validate prerequisites (caller should check, but be defensive)
    if(NOT _VCPKG_EDITABLE)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: _VCPKG_EDITABLE must be TRUE")
    endif()
    if(NOT DEFINED _VCPKG_EDITABLE_SOURCES_PATH)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: _VCPKG_EDITABLE_SOURCES_PATH must be defined")
    endif()
    if(NOT DEFINED PORT)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: PORT must be defined")
    endif()

    # Validate required arguments upfront
    if(NOT DEFINED arg_OUT_SOURCE_PATH)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: OUT_SOURCE_PATH must be specified")
    endif()

    # Find git once at the start
    find_program(GIT NAMES git git.cmd REQUIRED)

    # Backup and set GIT_CONFIG_NOSYSTEM to prevent system config from affecting git commands
    if(DEFINED ENV{GIT_CONFIG_NOSYSTEM})
        set(git_config_nosystem_backup "$ENV{GIT_CONFIG_NOSYSTEM}")
    else()
        unset(git_config_nosystem_backup)
    endif()
    set(ENV{GIT_CONFIG_NOSYSTEM} 1)

    # Consolidated git config options used for all git commands
    set(git_config_options -c core.longpaths=true -c core.autocrlf=false -c core.filemode=true -c user.name=vcpkg -c user.email=vcpkg@vcpkg)

    # Per-port source counter (starts at 0, so first call gets ${PORT}-src1)
    set(counter_var "_VCPKG_EDITABLE_SOURCE_COUNT_${PORT}")
    if(NOT DEFINED ${counter_var})
        set(${counter_var} 0 CACHE INTERNAL "Editable source download counter for ${PORT}")
    endif()
    math(EXPR new_count "${${counter_var}} + 1")
    set(${counter_var} ${new_count} CACHE INTERNAL "Editable source download counter for ${PORT}" FORCE)

    # Compute source path and metadata path: sources/${PORT}-src1, sources/${PORT}-src1.meta.json, etc.
    set(source_name "${PORT}-src${new_count}")
    set(editable_source_path "${_VCPKG_EDITABLE_SOURCES_PATH}/${source_name}")
    z_vcpkg_editable_get_meta_path(meta_file_path "${_VCPKG_EDITABLE_SOURCES_PATH}" "${source_name}")

    # Determine the effective REF to use
    set(using_head_version FALSE)
    if(VCPKG_USE_HEAD_VERSION AND DEFINED arg_HEAD_REF)
        set(using_head_version TRUE)
        set(ref_to_use "${arg_HEAD_REF}")
    elseif(DEFINED arg_REF)
        set(ref_to_use "${arg_REF}")
    else()
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: REF or HEAD_REF must be specified")
    endif()

    # Normalize optional parameters for metadata comparison
    if(DEFINED arg_FETCH_REF)
        set(fetch_ref_for_meta "${arg_FETCH_REF}")
    else()
        set(fetch_ref_for_meta "")
    endif()
    if(DEFINED arg_LFS)
        set(lfs_for_meta "${arg_LFS}")
    else()
        set(lfs_for_meta "")
    endif()

    # Determine what to fetch (FETCH_REF if specified, otherwise the ref itself)
    if(DEFINED arg_FETCH_REF)
        set(ref_to_fetch "${arg_FETCH_REF}")
    else()
        set(ref_to_fetch "${ref_to_use}")
    endif()

    # Build authenticated URL if token provided
    set(clone_url "${arg_URL}")
    if(DEFINED arg_AUTHORIZATION_TOKEN)
        # Insert token into HTTPS URL: https://TOKEN@github.com/...
        if(clone_url MATCHES "^https://(.*)$")
            set(clone_url "https://${arg_AUTHORIZATION_TOKEN}@${CMAKE_MATCH_1}")
        endif()
    endif()

    # Source already exists - check for configuration drift, fetch updates, and reuse
    if(EXISTS "${editable_source_path}")
        # Check if current parameters match what was originally used
        z_vcpkg_editable_check_metadata(
            meta_matches
            meta_diff_message
            "${meta_file_path}"
            "${arg_URL}"
            "${ref_to_use}"
            "${arg_PATCHES}"
            "${fetch_ref_for_meta}"
            "${lfs_for_meta}"
        )
        
        if(meta_matches)
            # Parameters match - silently reuse existing source
            message(STATUS "Editable mode: using existing source at ${editable_source_path}")
        else()
            # Parameters differ - warn user about the mismatch
            message(WARNING "Editable mode: Configuration drift detected!\n"
                "  Source path: ${editable_source_path}\n"
                "  The port's source parameters have changed since the editable source was created:${meta_diff_message}\n"
                "\n"
                "  The existing editable source will be used as-is.\n"
                "  To apply the new configuration, delete the source directory and metadata file, then rebuild:\n"
                "    ${editable_source_path}\n"
                "    ${meta_file_path}\n"
                "\n"
                "  Or update ${source_name}.git-metadata.json if this change is intentional."
            )
        endif()

        # Fetch latest changes from remote (non-blocking, for user convenience)
        message(STATUS "Editable mode: fetching latest changes from remote...")
        set(fetch_logname "git-fetch-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" ${git_config_options} fetch origin
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_logname}-err.log"
            RESULT_VARIABLE git_fetch_result
        )
        if(NOT git_fetch_result EQUAL 0)
            message(WARNING "Editable mode: git fetch failed (continuing with existing source)")
        endif()

        # Export HEAD version if using head
        if(using_head_version)
            set(rev_parse_logname "git-rev-parse-${TARGET_TRIPLET}")
            vcpkg_execute_in_download_mode(
                COMMAND "${GIT}" rev-parse HEAD
                WORKING_DIRECTORY "${editable_source_path}"
                OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${rev_parse_logname}-out.log"
                ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${rev_parse_logname}-err.log"
                OUTPUT_VARIABLE head_sha
                RESULT_VARIABLE rev_parse_result
            )
            if(rev_parse_result EQUAL 0)
                string(STRIP "${head_sha}" head_sha)
                set(VCPKG_HEAD_VERSION "${head_sha}" PARENT_SCOPE)
            endif()
        endif()

        # Restore GIT_CONFIG_NOSYSTEM before early return
        if(DEFINED git_config_nosystem_backup)
            set(ENV{GIT_CONFIG_NOSYSTEM} "${git_config_nosystem_backup}")
        else()
            unset(ENV{GIT_CONFIG_NOSYSTEM})
        endif()
        
        set("${arg_OUT_SOURCE_PATH}" "${editable_source_path}" PARENT_SCOPE)
        return()
    endif()

    # === INITIAL CLONE MODE ===
    # From this point on, any failure will cleanup the source folder and metadata file.
    # This ensures we never leave a half-baked repository.
    # Future: Update mode will NOT cleanup on failure, allowing recovery.
    set(is_initial_clone TRUE)

    # Validate required arguments
    if(NOT DEFINED arg_URL)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: URL must be specified")
    endif()

    # Ensure parent directory exists
    file(MAKE_DIRECTORY "${_VCPKG_EDITABLE_SOURCES_PATH}")

    # Full clone (not shallow, not single-branch) to enable proper git workflow
    message(STATUS "Editable mode: cloning ${arg_URL} to ${editable_source_path}")
    set(clone_logname "git-clone-${TARGET_TRIPLET}")
    vcpkg_execute_in_download_mode(
        COMMAND "${GIT}" ${git_config_options} clone "${clone_url}" "${editable_source_path}"
        WORKING_DIRECTORY "${_VCPKG_EDITABLE_SOURCES_PATH}"
        OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${clone_logname}-out.log"
        ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${clone_logname}-err.log"
        RESULT_VARIABLE git_clone_result
    )
    if(NOT git_clone_result EQUAL 0)
        z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git clone failed for ${arg_URL}\n"
            "  See logs: ${CURRENT_BUILDTREES_DIR}/${clone_logname}-out.log\n"
            "            ${CURRENT_BUILDTREES_DIR}/${clone_logname}-err.log")
    endif()

    # Fetch all refs and tags (needed for tag-based REFs)
    set(fetch_all_logname "git-fetch-all-${TARGET_TRIPLET}")
    vcpkg_execute_in_download_mode(
        COMMAND "${GIT}" ${git_config_options} fetch --all --tags
        WORKING_DIRECTORY "${editable_source_path}"
        OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_all_logname}-out.log"
        ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_all_logname}-err.log"
        RESULT_VARIABLE git_fetch_all_result
    )
    if(NOT git_fetch_all_result EQUAL 0)
        message(WARNING "Editable mode: git fetch --all --tags failed (continuing anyway)")
    endif()

    # Fetch the specific ref if FETCH_REF is different from REF
    if(DEFINED arg_FETCH_REF)
        message(STATUS "Editable mode: fetching ${arg_FETCH_REF}...")
        set(fetch_ref_logname "git-fetch-ref-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" ${git_config_options} fetch origin "${arg_FETCH_REF}"
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_ref_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${fetch_ref_logname}-err.log"
            RESULT_VARIABLE git_fetch_result
        )
        if(NOT git_fetch_result EQUAL 0)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git fetch '${arg_FETCH_REF}' failed\n"
                "  See logs: ${CURRENT_BUILDTREES_DIR}/${fetch_ref_logname}-out.log\n"
                "            ${CURRENT_BUILDTREES_DIR}/${fetch_ref_logname}-err.log")
        endif()
    endif()

    # Checkout specific ref - use --force to handle any file mode/line ending differences
    set(checkout_logname "git-checkout-${TARGET_TRIPLET}")
    vcpkg_execute_in_download_mode(
        COMMAND "${GIT}" ${git_config_options} checkout --force "${ref_to_use}"
        WORKING_DIRECTORY "${editable_source_path}"
        OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${checkout_logname}-out.log"
        ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${checkout_logname}-err.log"
        RESULT_VARIABLE git_checkout_result
    )
    if(NOT git_checkout_result EQUAL 0)
        z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git checkout '${ref_to_use}' failed\n"
            "  See logs: ${CURRENT_BUILDTREES_DIR}/${checkout_logname}-out.log\n"
            "            ${CURRENT_BUILDTREES_DIR}/${checkout_logname}-err.log")
    endif()

    # Handle Git LFS if requested
    if(DEFINED arg_LFS)
        # Determine LFS URL (empty string means use main URL)
        if("${arg_LFS}" STREQUAL "")
            set(lfs_url "${arg_URL}")
        else()
            set(lfs_url "${arg_LFS}")
        endif()

        # Verify git-lfs is available
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" lfs --version
            OUTPUT_VARIABLE lfs_version_output
            ERROR_VARIABLE lfs_version_error
            RESULT_VARIABLE lfs_version_result
            WORKING_DIRECTORY "${editable_source_path}"
        )
        if(lfs_version_result)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: Git LFS is required for ${PORT} but 'git lfs' is not available")
        endif()

        message(STATUS "Editable mode: setting up Git LFS...")
        set(lfs_install_logname "git-lfs-install-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" lfs install --local --force
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_install_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_install_logname}-err.log"
            RESULT_VARIABLE lfs_install_result
        )
        if(NOT lfs_install_result EQUAL 0)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git lfs install failed\n"
                "  See logs: ${CURRENT_BUILDTREES_DIR}/${lfs_install_logname}-out.log\n"
                "            ${CURRENT_BUILDTREES_DIR}/${lfs_install_logname}-err.log")
        endif()

        message(STATUS "Editable mode: fetching LFS objects from ${lfs_url}...")
        set(lfs_fetch_logname "git-lfs-fetch-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" lfs fetch "${lfs_url}" "${ref_to_use}"
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_fetch_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_fetch_logname}-err.log"
            RESULT_VARIABLE lfs_fetch_result
        )
        if(NOT lfs_fetch_result EQUAL 0)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git lfs fetch failed\n"
                "  See logs: ${CURRENT_BUILDTREES_DIR}/${lfs_fetch_logname}-out.log\n"
                "            ${CURRENT_BUILDTREES_DIR}/${lfs_fetch_logname}-err.log")
        endif()

        set(lfs_checkout_logname "git-lfs-checkout-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" lfs checkout
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_checkout_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${lfs_checkout_logname}-err.log"
            RESULT_VARIABLE lfs_checkout_result
        )
        if(NOT lfs_checkout_result EQUAL 0)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git lfs checkout failed\n"
                "  See logs: ${CURRENT_BUILDTREES_DIR}/${lfs_checkout_logname}-out.log\n"
                "            ${CURRENT_BUILDTREES_DIR}/${lfs_checkout_logname}-err.log")
        endif()
    endif()

    # Get the resolved SHA (needed for metadata and VCPKG_HEAD_VERSION)
    vcpkg_execute_in_download_mode(
        COMMAND "${GIT}" rev-parse HEAD
        WORKING_DIRECTORY "${editable_source_path}"
        OUTPUT_VARIABLE resolved_sha
        RESULT_VARIABLE rev_parse_result
    )
    if(rev_parse_result EQUAL 0)
        string(STRIP "${resolved_sha}" resolved_sha)
    else()
        set(resolved_sha "")
        message(WARNING "Editable mode: failed to determine HEAD commit SHA")
    endif()

    # Export VCPKG_HEAD_VERSION if using head version
    if(using_head_version)
        if(NOT "${resolved_sha}" STREQUAL "")
            set(VCPKG_HEAD_VERSION "${resolved_sha}" PARENT_SCOPE)
            message(STATUS "Editable mode: HEAD version is ${resolved_sha}")
        endif()
    endif()

    # Apply patches one by one using z_vcpkg_apply_patches, then commit each
    # This uses the standard vcpkg patch application with proper git flags
    set(patch_num 0)
    foreach(patch IN LISTS arg_PATCHES)
        # Apply patch using z_vcpkg_apply_patches for consistent behavior with vcpkg
        # (handles core.longpaths, core.autocrlf, core.filemode, logging, and patch existence check)
        z_vcpkg_apply_patches(
            SOURCE_PATH "${editable_source_path}"
            PATCHES "${patch}"
        )

        # Stage and commit the patch changes
        set(add_logname "git-add-patch-${patch_num}-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" ${git_config_options} add -A
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${add_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${add_logname}-err.log"
            RESULT_VARIABLE git_add_result
        )
        if(NOT git_add_result EQUAL 0)
            z_vcpkg_editable_cleanup_on_failure("${editable_source_path}" "${meta_file_path}")
            message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION}: git add failed after applying ${patch}\n"
                "  See logs: ${CURRENT_BUILDTREES_DIR}/${add_logname}-out.log\n"
                "            ${CURRENT_BUILDTREES_DIR}/${add_logname}-err.log")
        endif()

        # Extract patch filename for commit message
        get_filename_component(patch_name "${patch}" NAME)
        set(commit_logname "git-commit-patch-${patch_num}-${TARGET_TRIPLET}")
        vcpkg_execute_in_download_mode(
            COMMAND "${GIT}" ${git_config_options} commit -m "Apply vcpkg patch: ${patch_name}"
            WORKING_DIRECTORY "${editable_source_path}"
            OUTPUT_FILE "${CURRENT_BUILDTREES_DIR}/${commit_logname}-out.log"
            ERROR_FILE "${CURRENT_BUILDTREES_DIR}/${commit_logname}-err.log"
            RESULT_VARIABLE git_commit_result
        )
        if(NOT git_commit_result EQUAL 0)
            # Commit might fail if patch made no changes - that's OK
            message(STATUS "Editable mode: no changes to commit for patch ${patch_name}")
        endif()
        
        math(EXPR patch_num "${patch_num} + 1")
    endforeach()

    # Store metadata for configuration drift detection on future calls
    z_vcpkg_editable_write_metadata(
        "${meta_file_path}"
        "${arg_URL}"
        "${ref_to_use}"
        "${arg_PATCHES}"
        "${resolved_sha}"
        "${fetch_ref_for_meta}"
        "${lfs_for_meta}"
    )

    message(STATUS "Editable mode: source ready at ${editable_source_path}")

    # Restore GIT_CONFIG_NOSYSTEM
    if(DEFINED git_config_nosystem_backup)
        set(ENV{GIT_CONFIG_NOSYSTEM} "${git_config_nosystem_backup}")
    else()
        unset(ENV{GIT_CONFIG_NOSYSTEM})
    endif()

    set("${arg_OUT_SOURCE_PATH}" "${editable_source_path}" PARENT_SCOPE)
endfunction()
